"use strict";
(self["webpackChunkfrontend"] = self["webpackChunkfrontend"] || []).push([["vendors-node_modules_stencil_core_internal_client_shadow-css_js"],{

/***/ "./node_modules/@stencil/core/internal/client/shadow-css.js":
/*!******************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/client/shadow-css.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scopeCss: () => (/* binding */ scopeCss)
/* harmony export */ });
/*
 Stencil Client Platform v4.12.0 | MIT Licensed | https://stenciljs.com
 */
/**
 * Utility function that will escape all regular expression special characters in a string.
 *
 * @param text The string potentially containing special characters.
 * @returns The string with all special characters escaped.
 */
const escapeRegExpSpecialCharacters = (text) => {
    return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 *
 * This file is a port of shadowCSS from `webcomponents.js` to TypeScript.
 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
 * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts
 */
const safeSelector = (selector) => {
    const placeholders = [];
    let index = 0;
    // Replaces attribute selectors with placeholders.
    // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.
    selector = selector.replace(/(\[[^\]]*\])/g, (_, keep) => {
        const replaceBy = `__ph-${index}__`;
        placeholders.push(keep);
        index++;
        return replaceBy;
    });
    // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
    // WS and "+" would otherwise be interpreted as selector separators.
    const content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
        const replaceBy = `__ph-${index}__`;
        placeholders.push(exp);
        index++;
        return pseudo + replaceBy;
    });
    const ss = {
        content,
        placeholders,
    };
    return ss;
};
const restoreSafeSelector = (placeholders, content) => {
    return content.replace(/__ph-(\d+)__/g, (_, index) => placeholders[+index]);
};
const _polyfillHost = '-shadowcsshost';
const _polyfillSlotted = '-shadowcssslotted';
// note: :host-context pre-processed to -shadowcsshostcontext.
const _polyfillHostContext = '-shadowcsscontext';
const _parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';
const _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
const _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
const _cssColonSlottedRe = new RegExp('(' + _polyfillSlotted + _parenSuffix, 'gim');
const _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
const _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
const _shadowDOMSelectorsRe = [/::shadow/g, /::content/g];
const _selectorReSuffix = '([>\\s~+[.,{:][\\s\\S]*)?$';
const _polyfillHostRe = /-shadowcsshost/gim;
/**
 * Little helper for generating a regex that will match a specified
 * CSS selector when that selector is _not_ a part of a `@supports` rule.
 *
 * The pattern will match the provided `selector` (i.e. ':host', ':host-context', etc.)
 * when that selector is not a part of a `@supports` selector rule _or_ if the selector
 * is a part of the rule's declaration.
 *
 * For instance, if we create the regex with the selector ':host-context':
 * - '@supports selector(:host-context())' will return no matches (starts with '@supports')
 * - '@supports selector(:host-context()) { :host-context() { ... }}' will match the second ':host-context' (part of declaration)
 * - ':host-context() { ... }' will match ':host-context' (selector is not a '@supports' rule)
 * - ':host() { ... }' will return no matches (selector doesn't match selector used to create regex)
 *
 * @param selector The CSS selector we want to match for replacement
 * @returns A look-behind regex containing the selector
 */
const createSupportsRuleRe = (selector) => new RegExp(`((?<!(^@supports(.*)))|(?<=\{.*))(${selector}\\b)`, 'gim');
const _colonSlottedRe = createSupportsRuleRe('::slotted');
const _colonHostRe = createSupportsRuleRe(':host');
const _colonHostContextRe = createSupportsRuleRe(':host-context');
const _commentRe = /\/\*\s*[\s\S]*?\*\//g;
const stripComments = (input) => {
    return input.replace(_commentRe, '');
};
const _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
const extractCommentsWithHash = (input) => {
    return input.match(_commentWithHashRe) || [];
};
const _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
const _curlyRe = /([{}])/g;
const _selectorPartsRe = /(^.*?[^\\])??((:+)(.*)|$)/;
const OPEN_CURLY = '{';
const CLOSE_CURLY = '}';
const BLOCK_PLACEHOLDER = '%BLOCK%';
const processRules = (input, ruleCallback) => {
    const inputWithEscapedBlocks = escapeBlocks(input);
    let nextBlockIndex = 0;
    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {
        const selector = m[2];
        let content = '';
        let suffix = m[4];
        let contentPrefix = '';
        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
            contentPrefix = '{';
        }
        const cssRule = {
            selector,
            content,
        };
        const rule = ruleCallback(cssRule);
        return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
    });
};
const escapeBlocks = (input) => {
    const inputParts = input.split(_curlyRe);
    const resultParts = [];
    const escapedBlocks = [];
    let bracketCount = 0;
    let currentBlockParts = [];
    for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {
        const part = inputParts[partIndex];
        if (part === CLOSE_CURLY) {
            bracketCount--;
        }
        if (bracketCount > 0) {
            currentBlockParts.push(part);
        }
        else {
            if (currentBlockParts.length > 0) {
                escapedBlocks.push(currentBlockParts.join(''));
                resultParts.push(BLOCK_PLACEHOLDER);
                currentBlockParts = [];
            }
            resultParts.push(part);
        }
        if (part === OPEN_CURLY) {
            bracketCount++;
        }
    }
    if (currentBlockParts.length > 0) {
        escapedBlocks.push(currentBlockParts.join(''));
        resultParts.push(BLOCK_PLACEHOLDER);
    }
    const strEscapedBlocks = {
        escapedString: resultParts.join(''),
        blocks: escapedBlocks,
    };
    return strEscapedBlocks;
};
/**
 * Replaces certain strings within the CSS with placeholders
 * that will later be replaced with class selectors appropriate
 * for the level of encapsulation (shadow or scoped).
 *
 * When performing these replacements, we want to ignore selectors that are a
 * part of an `@supports` rule. Replacing these selectors will result in invalid
 * CSS that gets passed to autoprefixer/postcss once the placeholders are replaced.
 * For example, a rule like:
 *
 * ```css
 * @supports selector(:host()) {
 *   :host {
 *     color: red;
 *   }
 * }
 * ```
 *
 * Should be converted to:
 *
 * ```css
 * @supports selector(:host()) {
 *   -shadowcsshost {
 *     color: red;
 *   }
 * }
 * ```
 *
 * The order the regex replacements happen in matters since we match
 * against a whole selector word so we need to match all of `:host-context`
 * before we try to replace `:host`. Otherwise the pattern for `:host` would match
 * `:host-context` resulting in something like `:-shadowcsshost-context`.
 *
 * @param cssText A CSS string for a component
 * @returns The modified CSS string
 */
const insertPolyfillHostInCssText = (cssText) => {
    // These replacements use a special syntax with the `$1`. When the replacement
    // occurs, `$1` maps to the content of the string leading up to the selector
    // to be replaced.
    //
    // Otherwise, we will replace all the preceding content in addition to the
    // selector because of the lookbehind in the regex.
    //
    // e.g. `/*!@___0___*/:host {}` => `/*!@___0___*/--shadowcsshost {}`
    cssText = cssText
        .replace(_colonHostContextRe, `$1${_polyfillHostContext}`)
        .replace(_colonHostRe, `$1${_polyfillHost}`)
        .replace(_colonSlottedRe, `$1${_polyfillSlotted}`);
    return cssText;
};
const convertColonRule = (cssText, regExp, partReplacer) => {
    // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
    return cssText.replace(regExp, (...m) => {
        if (m[2]) {
            const parts = m[2].split(',');
            const r = [];
            for (let i = 0; i < parts.length; i++) {
                const p = parts[i].trim();
                if (!p)
                    break;
                r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
            }
            return r.join(',');
        }
        else {
            return _polyfillHostNoCombinator + m[3];
        }
    });
};
const colonHostPartReplacer = (host, part, suffix) => {
    return host + part.replace(_polyfillHost, '') + suffix;
};
const convertColonHost = (cssText) => {
    return convertColonRule(cssText, _cssColonHostRe, colonHostPartReplacer);
};
const colonHostContextPartReplacer = (host, part, suffix) => {
    if (part.indexOf(_polyfillHost) > -1) {
        return colonHostPartReplacer(host, part, suffix);
    }
    else {
        return host + part + suffix + ', ' + part + ' ' + host + suffix;
    }
};
const convertColonSlotted = (cssText, slotScopeId) => {
    const slotClass = '.' + slotScopeId + ' > ';
    const selectors = [];
    cssText = cssText.replace(_cssColonSlottedRe, (...m) => {
        if (m[2]) {
            const compound = m[2].trim();
            const suffix = m[3];
            const slottedSelector = slotClass + compound + suffix;
            let prefixSelector = '';
            for (let i = m[4] - 1; i >= 0; i--) {
                const char = m[5][i];
                if (char === '}' || char === ',') {
                    break;
                }
                prefixSelector = char + prefixSelector;
            }
            const orgSelector = (prefixSelector + slottedSelector).trim();
            const addedSelector = `${prefixSelector.trimEnd()}${slottedSelector.trim()}`.trim();
            if (orgSelector !== addedSelector) {
                const updatedSelector = `${addedSelector}, ${orgSelector}`;
                selectors.push({
                    orgSelector,
                    updatedSelector,
                });
            }
            return slottedSelector;
        }
        else {
            return _polyfillHostNoCombinator + m[3];
        }
    });
    return {
        selectors,
        cssText,
    };
};
const convertColonHostContext = (cssText) => {
    return convertColonRule(cssText, _cssColonHostContextRe, colonHostContextPartReplacer);
};
const convertShadowDOMSelectors = (cssText) => {
    return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);
};
const makeScopeMatcher = (scopeSelector) => {
    const lre = /\[/g;
    const rre = /\]/g;
    scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
    return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
};
const selectorNeedsScoping = (selector, scopeSelector) => {
    const re = makeScopeMatcher(scopeSelector);
    return !re.test(selector);
};
const injectScopingSelector = (selector, scopingSelector) => {
    return selector.replace(_selectorPartsRe, (_, before = '', _colonGroup, colon = '', after = '') => {
        return before + scopingSelector + colon + after;
    });
};
const applySimpleSelectorScope = (selector, scopeSelector, hostSelector) => {
    // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
    _polyfillHostRe.lastIndex = 0;
    if (_polyfillHostRe.test(selector)) {
        const replaceBy = `.${hostSelector}`;
        return selector
            .replace(_polyfillHostNoCombinatorRe, (_, selector) => injectScopingSelector(selector, replaceBy))
            .replace(_polyfillHostRe, replaceBy + ' ');
    }
    return scopeSelector + ' ' + selector;
};
const applyStrictSelectorScope = (selector, scopeSelector, hostSelector) => {
    const isRe = /\[is=([^\]]*)\]/g;
    scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
    const className = '.' + scopeSelector;
    const _scopeSelectorPart = (p) => {
        let scopedP = p.trim();
        if (!scopedP) {
            return '';
        }
        if (p.indexOf(_polyfillHostNoCombinator) > -1) {
            scopedP = applySimpleSelectorScope(p, scopeSelector, hostSelector);
        }
        else {
            // remove :host since it should be unnecessary
            const t = p.replace(_polyfillHostRe, '');
            if (t.length > 0) {
                scopedP = injectScopingSelector(t, className);
            }
        }
        return scopedP;
    };
    const safeContent = safeSelector(selector);
    selector = safeContent.content;
    let scopedSelector = '';
    let startIndex = 0;
    let res;
    const sep = /( |>|\+|~(?!=))\s*/g;
    // If a selector appears before :host it should not be shimmed as it
    // matches on ancestor elements and not on elements in the host's shadow
    // `:host-context(div)` is transformed to
    // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`
    // the `div` is not part of the component in the 2nd selectors and should not be scoped.
    // Historically `component-tag:host` was matching the component so we also want to preserve
    // this behavior to avoid breaking legacy apps (it should not match).
    // The behavior should be:
    // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)
    // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a
    //   `:host-context(tag)`)
    const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;
    // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present
    let shouldScope = !hasHost;
    while ((res = sep.exec(selector)) !== null) {
        const separator = res[1];
        const part = selector.slice(startIndex, res.index).trim();
        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
        const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;
        scopedSelector += `${scopedPart} ${separator} `;
        startIndex = sep.lastIndex;
    }
    const part = selector.substring(startIndex);
    shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
    scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;
    // replace the placeholders with their original values
    return restoreSafeSelector(safeContent.placeholders, scopedSelector);
};
const scopeSelector = (selector, scopeSelectorText, hostSelector, slotSelector) => {
    return selector
        .split(',')
        .map((shallowPart) => {
        if (slotSelector && shallowPart.indexOf('.' + slotSelector) > -1) {
            return shallowPart.trim();
        }
        if (selectorNeedsScoping(shallowPart, scopeSelectorText)) {
            return applyStrictSelectorScope(shallowPart, scopeSelectorText, hostSelector).trim();
        }
        else {
            return shallowPart.trim();
        }
    })
        .join(', ');
};
const scopeSelectors = (cssText, scopeSelectorText, hostSelector, slotSelector, commentOriginalSelector) => {
    return processRules(cssText, (rule) => {
        let selector = rule.selector;
        let content = rule.content;
        if (rule.selector[0] !== '@') {
            selector = scopeSelector(rule.selector, scopeSelectorText, hostSelector, slotSelector);
        }
        else if (rule.selector.startsWith('@media') ||
            rule.selector.startsWith('@supports') ||
            rule.selector.startsWith('@page') ||
            rule.selector.startsWith('@document')) {
            content = scopeSelectors(rule.content, scopeSelectorText, hostSelector, slotSelector);
        }
        const cssRule = {
            selector: selector.replace(/\s{2,}/g, ' ').trim(),
            content,
        };
        return cssRule;
    });
};
const scopeCssText = (cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector) => {
    cssText = insertPolyfillHostInCssText(cssText);
    cssText = convertColonHost(cssText);
    cssText = convertColonHostContext(cssText);
    const slotted = convertColonSlotted(cssText, slotScopeId);
    cssText = slotted.cssText;
    cssText = convertShadowDOMSelectors(cssText);
    if (scopeId) {
        cssText = scopeSelectors(cssText, scopeId, hostScopeId, slotScopeId);
    }
    cssText = replaceShadowCssHost(cssText, hostScopeId);
    cssText = cssText.replace(/>\s*\*\s+([^{, ]+)/gm, ' $1 ');
    return {
        cssText: cssText.trim(),
        // We need to replace the shadow CSS host string in each of these selectors since we created
        // them prior to the replacement happening in the components CSS text.
        slottedSelectors: slotted.selectors.map((ref) => ({
            orgSelector: replaceShadowCssHost(ref.orgSelector, hostScopeId),
            updatedSelector: replaceShadowCssHost(ref.updatedSelector, hostScopeId),
        })),
    };
};
/**
 * Helper function that replaces the interim string representing a `:host` selector with
 * the host scope selector class for the element.
 *
 * @param cssText The CSS string to make the replacement in
 * @param hostScopeId The scope ID that will be used as the class representing the host element
 * @returns CSS with the selector replaced
 */
const replaceShadowCssHost = (cssText, hostScopeId) => {
    return cssText.replace(/-shadowcsshost-no-combinator/g, `.${hostScopeId}`);
};
const scopeCss = (cssText, scopeId, commentOriginalSelector) => {
    const hostScopeId = scopeId + '-h';
    const slotScopeId = scopeId + '-s';
    const commentsWithHash = extractCommentsWithHash(cssText);
    cssText = stripComments(cssText);
    const orgSelectors = [];
    if (commentOriginalSelector) {
        const processCommentedSelector = (rule) => {
            const placeholder = `/*!@___${orgSelectors.length}___*/`;
            const comment = `/*!@${rule.selector}*/`;
            orgSelectors.push({ placeholder, comment });
            rule.selector = placeholder + rule.selector;
            return rule;
        };
        cssText = processRules(cssText, (rule) => {
            if (rule.selector[0] !== '@') {
                return processCommentedSelector(rule);
            }
            else if (rule.selector.startsWith('@media') ||
                rule.selector.startsWith('@supports') ||
                rule.selector.startsWith('@page') ||
                rule.selector.startsWith('@document')) {
                rule.content = processRules(rule.content, processCommentedSelector);
                return rule;
            }
            return rule;
        });
    }
    const scoped = scopeCssText(cssText, scopeId, hostScopeId, slotScopeId);
    cssText = [scoped.cssText, ...commentsWithHash].join('\n');
    if (commentOriginalSelector) {
        orgSelectors.forEach(({ placeholder, comment }) => {
            cssText = cssText.replace(placeholder, comment);
        });
    }
    scoped.slottedSelectors.forEach((slottedSelector) => {
        const regex = new RegExp(escapeRegExpSpecialCharacters(slottedSelector.orgSelector), 'g');
        cssText = cssText.replace(regex, slottedSelector.updatedSelector);
    });
    return cssText;
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc3RlbmNpbF9jb3JlX2ludGVybmFsX2NsaWVudF9zaGFkb3ctY3NzX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0JBQWtCLE1BQU07QUFDcEUsd0JBQXdCLEtBQUs7QUFDN0IsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsT0FBTyxTQUFTO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRSxFQUFFLGNBQWMsUUFBUSxLQUFLLFVBQVU7QUFDbkUsc0JBQXNCO0FBQ3RCO0FBQ0EscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsWUFBWTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlELG1DQUFtQyxjQUFjO0FBQ2pELGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9zaGFkb3ctY3NzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiBTdGVuY2lsIENsaWVudCBQbGF0Zm9ybSB2NC4xMi4wIHwgTUlUIExpY2Vuc2VkIHwgaHR0cHM6Ly9zdGVuY2lsanMuY29tXHJcbiAqL1xyXG4vKipcclxuICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IHdpbGwgZXNjYXBlIGFsbCByZWd1bGFyIGV4cHJlc3Npb24gc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGEgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dCBUaGUgc3RyaW5nIHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nIHdpdGggYWxsIHNwZWNpYWwgY2hhcmFjdGVycyBlc2NhcGVkLlxyXG4gKi9cclxuY29uc3QgZXNjYXBlUmVnRXhwU3BlY2lhbENoYXJhY3RlcnMgPSAodGV4dCkgPT4ge1xyXG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKlxyXG4gKiBUaGlzIGZpbGUgaXMgYSBwb3J0IG9mIHNoYWRvd0NTUyBmcm9tIGB3ZWJjb21wb25lbnRzLmpzYCB0byBUeXBlU2NyaXB0LlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMvYmxvYi80ZWZlY2Q3ZTBlL3NyYy9TaGFkb3dDU1MvU2hhZG93Q1NTLmpzXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9tYXN0ZXIvcGFja2FnZXMvY29tcGlsZXIvc3JjL3NoYWRvd19jc3MudHNcclxuICovXHJcbmNvbnN0IHNhZmVTZWxlY3RvciA9IChzZWxlY3RvcikgPT4ge1xyXG4gICAgY29uc3QgcGxhY2Vob2xkZXJzID0gW107XHJcbiAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgLy8gUmVwbGFjZXMgYXR0cmlidXRlIHNlbGVjdG9ycyB3aXRoIHBsYWNlaG9sZGVycy5cclxuICAgIC8vIFRoZSBXUyBpbiBbYXR0cj1cInZhIGx1ZVwiXSB3b3VsZCBvdGhlcndpc2UgYmUgaW50ZXJwcmV0ZWQgYXMgYSBzZWxlY3RvciBzZXBhcmF0b3IuXHJcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLyhcXFtbXlxcXV0qXFxdKS9nLCAoXywga2VlcCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlcGxhY2VCeSA9IGBfX3BoLSR7aW5kZXh9X19gO1xyXG4gICAgICAgIHBsYWNlaG9sZGVycy5wdXNoKGtlZXApO1xyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VCeTtcclxuICAgIH0pO1xyXG4gICAgLy8gUmVwbGFjZXMgdGhlIGV4cHJlc3Npb24gaW4gYDpudGgtY2hpbGQoMm4gKyAxKWAgd2l0aCBhIHBsYWNlaG9sZGVyLlxyXG4gICAgLy8gV1MgYW5kIFwiK1wiIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBzZWxlY3RvciBzZXBhcmF0b3JzLlxyXG4gICAgY29uc3QgY29udGVudCA9IHNlbGVjdG9yLnJlcGxhY2UoLyg6bnRoLVstXFx3XSspKFxcKFteKV0rXFwpKS9nLCAoXywgcHNldWRvLCBleHApID0+IHtcclxuICAgICAgICBjb25zdCByZXBsYWNlQnkgPSBgX19waC0ke2luZGV4fV9fYDtcclxuICAgICAgICBwbGFjZWhvbGRlcnMucHVzaChleHApO1xyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgcmV0dXJuIHBzZXVkbyArIHJlcGxhY2VCeTtcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc3MgPSB7XHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBwbGFjZWhvbGRlcnMsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHNzO1xyXG59O1xyXG5jb25zdCByZXN0b3JlU2FmZVNlbGVjdG9yID0gKHBsYWNlaG9sZGVycywgY29udGVudCkgPT4ge1xyXG4gICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvX19waC0oXFxkKylfXy9nLCAoXywgaW5kZXgpID0+IHBsYWNlaG9sZGVyc1sraW5kZXhdKTtcclxufTtcclxuY29uc3QgX3BvbHlmaWxsSG9zdCA9ICctc2hhZG93Y3NzaG9zdCc7XHJcbmNvbnN0IF9wb2x5ZmlsbFNsb3R0ZWQgPSAnLXNoYWRvd2Nzc3Nsb3R0ZWQnO1xyXG4vLyBub3RlOiA6aG9zdC1jb250ZXh0IHByZS1wcm9jZXNzZWQgdG8gLXNoYWRvd2Nzc2hvc3Rjb250ZXh0LlxyXG5jb25zdCBfcG9seWZpbGxIb3N0Q29udGV4dCA9ICctc2hhZG93Y3NzY29udGV4dCc7XHJcbmNvbnN0IF9wYXJlblN1ZmZpeCA9ICcpKD86XFxcXCgoJyArICcoPzpcXFxcKFteKShdKlxcXFwpfFteKShdKikrPycgKyAnKVxcXFwpKT8oW14se10qKSc7XHJcbmNvbnN0IF9jc3NDb2xvbkhvc3RSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdCArIF9wYXJlblN1ZmZpeCwgJ2dpbScpO1xyXG5jb25zdCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlID0gbmV3IFJlZ0V4cCgnKCcgKyBfcG9seWZpbGxIb3N0Q29udGV4dCArIF9wYXJlblN1ZmZpeCwgJ2dpbScpO1xyXG5jb25zdCBfY3NzQ29sb25TbG90dGVkUmUgPSBuZXcgUmVnRXhwKCcoJyArIF9wb2x5ZmlsbFNsb3R0ZWQgKyBfcGFyZW5TdWZmaXgsICdnaW0nKTtcclxuY29uc3QgX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciA9IF9wb2x5ZmlsbEhvc3QgKyAnLW5vLWNvbWJpbmF0b3InO1xyXG5jb25zdCBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUgPSAvLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcihbXlxcc10qKS87XHJcbmNvbnN0IF9zaGFkb3dET01TZWxlY3RvcnNSZSA9IFsvOjpzaGFkb3cvZywgLzo6Y29udGVudC9nXTtcclxuY29uc3QgX3NlbGVjdG9yUmVTdWZmaXggPSAnKFs+XFxcXHN+K1suLHs6XVtcXFxcc1xcXFxTXSopPyQnO1xyXG5jb25zdCBfcG9seWZpbGxIb3N0UmUgPSAvLXNoYWRvd2Nzc2hvc3QvZ2ltO1xyXG4vKipcclxuICogTGl0dGxlIGhlbHBlciBmb3IgZ2VuZXJhdGluZyBhIHJlZ2V4IHRoYXQgd2lsbCBtYXRjaCBhIHNwZWNpZmllZFxyXG4gKiBDU1Mgc2VsZWN0b3Igd2hlbiB0aGF0IHNlbGVjdG9yIGlzIF9ub3RfIGEgcGFydCBvZiBhIGBAc3VwcG9ydHNgIHJ1bGUuXHJcbiAqXHJcbiAqIFRoZSBwYXR0ZXJuIHdpbGwgbWF0Y2ggdGhlIHByb3ZpZGVkIGBzZWxlY3RvcmAgKGkuZS4gJzpob3N0JywgJzpob3N0LWNvbnRleHQnLCBldGMuKVxyXG4gKiB3aGVuIHRoYXQgc2VsZWN0b3IgaXMgbm90IGEgcGFydCBvZiBhIGBAc3VwcG9ydHNgIHNlbGVjdG9yIHJ1bGUgX29yXyBpZiB0aGUgc2VsZWN0b3JcclxuICogaXMgYSBwYXJ0IG9mIHRoZSBydWxlJ3MgZGVjbGFyYXRpb24uXHJcbiAqXHJcbiAqIEZvciBpbnN0YW5jZSwgaWYgd2UgY3JlYXRlIHRoZSByZWdleCB3aXRoIHRoZSBzZWxlY3RvciAnOmhvc3QtY29udGV4dCc6XHJcbiAqIC0gJ0BzdXBwb3J0cyBzZWxlY3Rvcig6aG9zdC1jb250ZXh0KCkpJyB3aWxsIHJldHVybiBubyBtYXRjaGVzIChzdGFydHMgd2l0aCAnQHN1cHBvcnRzJylcclxuICogLSAnQHN1cHBvcnRzIHNlbGVjdG9yKDpob3N0LWNvbnRleHQoKSkgeyA6aG9zdC1jb250ZXh0KCkgeyAuLi4gfX0nIHdpbGwgbWF0Y2ggdGhlIHNlY29uZCAnOmhvc3QtY29udGV4dCcgKHBhcnQgb2YgZGVjbGFyYXRpb24pXHJcbiAqIC0gJzpob3N0LWNvbnRleHQoKSB7IC4uLiB9JyB3aWxsIG1hdGNoICc6aG9zdC1jb250ZXh0JyAoc2VsZWN0b3IgaXMgbm90IGEgJ0BzdXBwb3J0cycgcnVsZSlcclxuICogLSAnOmhvc3QoKSB7IC4uLiB9JyB3aWxsIHJldHVybiBubyBtYXRjaGVzIChzZWxlY3RvciBkb2Vzbid0IG1hdGNoIHNlbGVjdG9yIHVzZWQgdG8gY3JlYXRlIHJlZ2V4KVxyXG4gKlxyXG4gKiBAcGFyYW0gc2VsZWN0b3IgVGhlIENTUyBzZWxlY3RvciB3ZSB3YW50IHRvIG1hdGNoIGZvciByZXBsYWNlbWVudFxyXG4gKiBAcmV0dXJucyBBIGxvb2stYmVoaW5kIHJlZ2V4IGNvbnRhaW5pbmcgdGhlIHNlbGVjdG9yXHJcbiAqL1xyXG5jb25zdCBjcmVhdGVTdXBwb3J0c1J1bGVSZSA9IChzZWxlY3RvcikgPT4gbmV3IFJlZ0V4cChgKCg/PCEoXkBzdXBwb3J0cyguKikpKXwoPzw9XFx7LiopKSgke3NlbGVjdG9yfVxcXFxiKWAsICdnaW0nKTtcclxuY29uc3QgX2NvbG9uU2xvdHRlZFJlID0gY3JlYXRlU3VwcG9ydHNSdWxlUmUoJzo6c2xvdHRlZCcpO1xyXG5jb25zdCBfY29sb25Ib3N0UmUgPSBjcmVhdGVTdXBwb3J0c1J1bGVSZSgnOmhvc3QnKTtcclxuY29uc3QgX2NvbG9uSG9zdENvbnRleHRSZSA9IGNyZWF0ZVN1cHBvcnRzUnVsZVJlKCc6aG9zdC1jb250ZXh0Jyk7XHJcbmNvbnN0IF9jb21tZW50UmUgPSAvXFwvXFwqXFxzKltcXHNcXFNdKj9cXCpcXC8vZztcclxuY29uc3Qgc3RyaXBDb21tZW50cyA9IChpbnB1dCkgPT4ge1xyXG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoX2NvbW1lbnRSZSwgJycpO1xyXG59O1xyXG5jb25zdCBfY29tbWVudFdpdGhIYXNoUmUgPSAvXFwvXFwqXFxzKiNcXHMqc291cmNlKE1hcHBpbmcpP1VSTD1bXFxzXFxTXSs/XFwqXFwvL2c7XHJcbmNvbnN0IGV4dHJhY3RDb21tZW50c1dpdGhIYXNoID0gKGlucHV0KSA9PiB7XHJcbiAgICByZXR1cm4gaW5wdXQubWF0Y2goX2NvbW1lbnRXaXRoSGFzaFJlKSB8fCBbXTtcclxufTtcclxuY29uc3QgX3J1bGVSZSA9IC8oXFxzKikoW147XFx7XFx9XSs/KShcXHMqKSgoPzp7JUJMT0NLJX0/XFxzKjs/KXwoPzpcXHMqOykpL2c7XHJcbmNvbnN0IF9jdXJseVJlID0gLyhbe31dKS9nO1xyXG5jb25zdCBfc2VsZWN0b3JQYXJ0c1JlID0gLyheLio/W15cXFxcXSk/PygoOispKC4qKXwkKS87XHJcbmNvbnN0IE9QRU5fQ1VSTFkgPSAneyc7XHJcbmNvbnN0IENMT1NFX0NVUkxZID0gJ30nO1xyXG5jb25zdCBCTE9DS19QTEFDRUhPTERFUiA9ICclQkxPQ0slJztcclxuY29uc3QgcHJvY2Vzc1J1bGVzID0gKGlucHV0LCBydWxlQ2FsbGJhY2spID0+IHtcclxuICAgIGNvbnN0IGlucHV0V2l0aEVzY2FwZWRCbG9ja3MgPSBlc2NhcGVCbG9ja3MoaW5wdXQpO1xyXG4gICAgbGV0IG5leHRCbG9ja0luZGV4ID0gMDtcclxuICAgIHJldHVybiBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzLmVzY2FwZWRTdHJpbmcucmVwbGFjZShfcnVsZVJlLCAoLi4ubSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gbVsyXTtcclxuICAgICAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgICAgIGxldCBzdWZmaXggPSBtWzRdO1xyXG4gICAgICAgIGxldCBjb250ZW50UHJlZml4ID0gJyc7XHJcbiAgICAgICAgaWYgKHN1ZmZpeCAmJiBzdWZmaXguc3RhcnRzV2l0aCgneycgKyBCTE9DS19QTEFDRUhPTERFUikpIHtcclxuICAgICAgICAgICAgY29udGVudCA9IGlucHV0V2l0aEVzY2FwZWRCbG9ja3MuYmxvY2tzW25leHRCbG9ja0luZGV4KytdO1xyXG4gICAgICAgICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKEJMT0NLX1BMQUNFSE9MREVSLmxlbmd0aCArIDEpO1xyXG4gICAgICAgICAgICBjb250ZW50UHJlZml4ID0gJ3snO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjc3NSdWxlID0ge1xyXG4gICAgICAgICAgICBzZWxlY3RvcixcclxuICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlQ2FsbGJhY2soY3NzUnVsZSk7XHJcbiAgICAgICAgcmV0dXJuIGAke21bMV19JHtydWxlLnNlbGVjdG9yfSR7bVszXX0ke2NvbnRlbnRQcmVmaXh9JHtydWxlLmNvbnRlbnR9JHtzdWZmaXh9YDtcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBlc2NhcGVCbG9ja3MgPSAoaW5wdXQpID0+IHtcclxuICAgIGNvbnN0IGlucHV0UGFydHMgPSBpbnB1dC5zcGxpdChfY3VybHlSZSk7XHJcbiAgICBjb25zdCByZXN1bHRQYXJ0cyA9IFtdO1xyXG4gICAgY29uc3QgZXNjYXBlZEJsb2NrcyA9IFtdO1xyXG4gICAgbGV0IGJyYWNrZXRDb3VudCA9IDA7XHJcbiAgICBsZXQgY3VycmVudEJsb2NrUGFydHMgPSBbXTtcclxuICAgIGZvciAobGV0IHBhcnRJbmRleCA9IDA7IHBhcnRJbmRleCA8IGlucHV0UGFydHMubGVuZ3RoOyBwYXJ0SW5kZXgrKykge1xyXG4gICAgICAgIGNvbnN0IHBhcnQgPSBpbnB1dFBhcnRzW3BhcnRJbmRleF07XHJcbiAgICAgICAgaWYgKHBhcnQgPT09IENMT1NFX0NVUkxZKSB7XHJcbiAgICAgICAgICAgIGJyYWNrZXRDb3VudC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnJhY2tldENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QmxvY2tQYXJ0cy5wdXNoKHBhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9ja1BhcnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGVzY2FwZWRCbG9ja3MucHVzaChjdXJyZW50QmxvY2tQYXJ0cy5qb2luKCcnKSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9ja1BhcnRzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0UGFydHMucHVzaChwYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcnQgPT09IE9QRU5fQ1VSTFkpIHtcclxuICAgICAgICAgICAgYnJhY2tldENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGN1cnJlbnRCbG9ja1BhcnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBlc2NhcGVkQmxvY2tzLnB1c2goY3VycmVudEJsb2NrUGFydHMuam9pbignJykpO1xyXG4gICAgICAgIHJlc3VsdFBhcnRzLnB1c2goQkxPQ0tfUExBQ0VIT0xERVIpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RyRXNjYXBlZEJsb2NrcyA9IHtcclxuICAgICAgICBlc2NhcGVkU3RyaW5nOiByZXN1bHRQYXJ0cy5qb2luKCcnKSxcclxuICAgICAgICBibG9ja3M6IGVzY2FwZWRCbG9ja3MsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHN0ckVzY2FwZWRCbG9ja3M7XHJcbn07XHJcbi8qKlxyXG4gKiBSZXBsYWNlcyBjZXJ0YWluIHN0cmluZ3Mgd2l0aGluIHRoZSBDU1Mgd2l0aCBwbGFjZWhvbGRlcnNcclxuICogdGhhdCB3aWxsIGxhdGVyIGJlIHJlcGxhY2VkIHdpdGggY2xhc3Mgc2VsZWN0b3JzIGFwcHJvcHJpYXRlXHJcbiAqIGZvciB0aGUgbGV2ZWwgb2YgZW5jYXBzdWxhdGlvbiAoc2hhZG93IG9yIHNjb3BlZCkuXHJcbiAqXHJcbiAqIFdoZW4gcGVyZm9ybWluZyB0aGVzZSByZXBsYWNlbWVudHMsIHdlIHdhbnQgdG8gaWdub3JlIHNlbGVjdG9ycyB0aGF0IGFyZSBhXHJcbiAqIHBhcnQgb2YgYW4gYEBzdXBwb3J0c2AgcnVsZS4gUmVwbGFjaW5nIHRoZXNlIHNlbGVjdG9ycyB3aWxsIHJlc3VsdCBpbiBpbnZhbGlkXHJcbiAqIENTUyB0aGF0IGdldHMgcGFzc2VkIHRvIGF1dG9wcmVmaXhlci9wb3N0Y3NzIG9uY2UgdGhlIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQuXHJcbiAqIEZvciBleGFtcGxlLCBhIHJ1bGUgbGlrZTpcclxuICpcclxuICogYGBgY3NzXHJcbiAqIEBzdXBwb3J0cyBzZWxlY3Rvcig6aG9zdCgpKSB7XHJcbiAqICAgOmhvc3Qge1xyXG4gKiAgICAgY29sb3I6IHJlZDtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFNob3VsZCBiZSBjb252ZXJ0ZWQgdG86XHJcbiAqXHJcbiAqIGBgYGNzc1xyXG4gKiBAc3VwcG9ydHMgc2VsZWN0b3IoOmhvc3QoKSkge1xyXG4gKiAgIC1zaGFkb3djc3Nob3N0IHtcclxuICogICAgIGNvbG9yOiByZWQ7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgb3JkZXIgdGhlIHJlZ2V4IHJlcGxhY2VtZW50cyBoYXBwZW4gaW4gbWF0dGVycyBzaW5jZSB3ZSBtYXRjaFxyXG4gKiBhZ2FpbnN0IGEgd2hvbGUgc2VsZWN0b3Igd29yZCBzbyB3ZSBuZWVkIHRvIG1hdGNoIGFsbCBvZiBgOmhvc3QtY29udGV4dGBcclxuICogYmVmb3JlIHdlIHRyeSB0byByZXBsYWNlIGA6aG9zdGAuIE90aGVyd2lzZSB0aGUgcGF0dGVybiBmb3IgYDpob3N0YCB3b3VsZCBtYXRjaFxyXG4gKiBgOmhvc3QtY29udGV4dGAgcmVzdWx0aW5nIGluIHNvbWV0aGluZyBsaWtlIGA6LXNoYWRvd2Nzc2hvc3QtY29udGV4dGAuXHJcbiAqXHJcbiAqIEBwYXJhbSBjc3NUZXh0IEEgQ1NTIHN0cmluZyBmb3IgYSBjb21wb25lbnRcclxuICogQHJldHVybnMgVGhlIG1vZGlmaWVkIENTUyBzdHJpbmdcclxuICovXHJcbmNvbnN0IGluc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dCA9IChjc3NUZXh0KSA9PiB7XHJcbiAgICAvLyBUaGVzZSByZXBsYWNlbWVudHMgdXNlIGEgc3BlY2lhbCBzeW50YXggd2l0aCB0aGUgYCQxYC4gV2hlbiB0aGUgcmVwbGFjZW1lbnRcclxuICAgIC8vIG9jY3VycywgYCQxYCBtYXBzIHRvIHRoZSBjb250ZW50IG9mIHRoZSBzdHJpbmcgbGVhZGluZyB1cCB0byB0aGUgc2VsZWN0b3JcclxuICAgIC8vIHRvIGJlIHJlcGxhY2VkLlxyXG4gICAgLy9cclxuICAgIC8vIE90aGVyd2lzZSwgd2Ugd2lsbCByZXBsYWNlIGFsbCB0aGUgcHJlY2VkaW5nIGNvbnRlbnQgaW4gYWRkaXRpb24gdG8gdGhlXHJcbiAgICAvLyBzZWxlY3RvciBiZWNhdXNlIG9mIHRoZSBsb29rYmVoaW5kIGluIHRoZSByZWdleC5cclxuICAgIC8vXHJcbiAgICAvLyBlLmcuIGAvKiFAX19fMF9fXyovOmhvc3Qge31gID0+IGAvKiFAX19fMF9fXyovLS1zaGFkb3djc3Nob3N0IHt9YFxyXG4gICAgY3NzVGV4dCA9IGNzc1RleHRcclxuICAgICAgICAucmVwbGFjZShfY29sb25Ib3N0Q29udGV4dFJlLCBgJDEke19wb2x5ZmlsbEhvc3RDb250ZXh0fWApXHJcbiAgICAgICAgLnJlcGxhY2UoX2NvbG9uSG9zdFJlLCBgJDEke19wb2x5ZmlsbEhvc3R9YClcclxuICAgICAgICAucmVwbGFjZShfY29sb25TbG90dGVkUmUsIGAkMSR7X3BvbHlmaWxsU2xvdHRlZH1gKTtcclxuICAgIHJldHVybiBjc3NUZXh0O1xyXG59O1xyXG5jb25zdCBjb252ZXJ0Q29sb25SdWxlID0gKGNzc1RleHQsIHJlZ0V4cCwgcGFydFJlcGxhY2VyKSA9PiB7XHJcbiAgICAvLyBtWzFdID0gOmhvc3QoLWNvbnRleHQpLCBtWzJdID0gY29udGVudHMgb2YgKCksIG1bM10gcmVzdCBvZiBydWxlXHJcbiAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKHJlZ0V4cCwgKC4uLm0pID0+IHtcclxuICAgICAgICBpZiAobVsyXSkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IG1bMl0uc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgY29uc3QgciA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbaV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgci5wdXNoKHBhcnRSZXBsYWNlcihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yLCBwLCBtWzNdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHIuam9pbignLCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgKyBtWzNdO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBjb2xvbkhvc3RQYXJ0UmVwbGFjZXIgPSAoaG9zdCwgcGFydCwgc3VmZml4KSA9PiB7XHJcbiAgICByZXR1cm4gaG9zdCArIHBhcnQucmVwbGFjZShfcG9seWZpbGxIb3N0LCAnJykgKyBzdWZmaXg7XHJcbn07XHJcbmNvbnN0IGNvbnZlcnRDb2xvbkhvc3QgPSAoY3NzVGV4dCkgPT4ge1xyXG4gICAgcmV0dXJuIGNvbnZlcnRDb2xvblJ1bGUoY3NzVGV4dCwgX2Nzc0NvbG9uSG9zdFJlLCBjb2xvbkhvc3RQYXJ0UmVwbGFjZXIpO1xyXG59O1xyXG5jb25zdCBjb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyID0gKGhvc3QsIHBhcnQsIHN1ZmZpeCkgPT4ge1xyXG4gICAgaWYgKHBhcnQuaW5kZXhPZihfcG9seWZpbGxIb3N0KSA+IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9uSG9zdFBhcnRSZXBsYWNlcihob3N0LCBwYXJ0LCBzdWZmaXgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGhvc3QgKyBwYXJ0ICsgc3VmZml4ICsgJywgJyArIHBhcnQgKyAnICcgKyBob3N0ICsgc3VmZml4O1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBjb252ZXJ0Q29sb25TbG90dGVkID0gKGNzc1RleHQsIHNsb3RTY29wZUlkKSA9PiB7XHJcbiAgICBjb25zdCBzbG90Q2xhc3MgPSAnLicgKyBzbG90U2NvcGVJZCArICcgPiAnO1xyXG4gICAgY29uc3Qgc2VsZWN0b3JzID0gW107XHJcbiAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb2xvblNsb3R0ZWRSZSwgKC4uLm0pID0+IHtcclxuICAgICAgICBpZiAobVsyXSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wb3VuZCA9IG1bMl0udHJpbSgpO1xyXG4gICAgICAgICAgICBjb25zdCBzdWZmaXggPSBtWzNdO1xyXG4gICAgICAgICAgICBjb25zdCBzbG90dGVkU2VsZWN0b3IgPSBzbG90Q2xhc3MgKyBjb21wb3VuZCArIHN1ZmZpeDtcclxuICAgICAgICAgICAgbGV0IHByZWZpeFNlbGVjdG9yID0gJyc7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBtWzRdIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBtWzVdW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICd9JyB8fCBjaGFyID09PSAnLCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZWZpeFNlbGVjdG9yID0gY2hhciArIHByZWZpeFNlbGVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9yZ1NlbGVjdG9yID0gKHByZWZpeFNlbGVjdG9yICsgc2xvdHRlZFNlbGVjdG9yKS50cmltKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkU2VsZWN0b3IgPSBgJHtwcmVmaXhTZWxlY3Rvci50cmltRW5kKCl9JHtzbG90dGVkU2VsZWN0b3IudHJpbSgpfWAudHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAob3JnU2VsZWN0b3IgIT09IGFkZGVkU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTZWxlY3RvciA9IGAke2FkZGVkU2VsZWN0b3J9LCAke29yZ1NlbGVjdG9yfWA7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JnU2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNsb3R0ZWRTZWxlY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yICsgbVszXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VsZWN0b3JzLFxyXG4gICAgICAgIGNzc1RleHQsXHJcbiAgICB9O1xyXG59O1xyXG5jb25zdCBjb252ZXJ0Q29sb25Ib3N0Q29udGV4dCA9IChjc3NUZXh0KSA9PiB7XHJcbiAgICByZXR1cm4gY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlLCBjb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyKTtcclxufTtcclxuY29uc3QgY29udmVydFNoYWRvd0RPTVNlbGVjdG9ycyA9IChjc3NUZXh0KSA9PiB7XHJcbiAgICByZXR1cm4gX3NoYWRvd0RPTVNlbGVjdG9yc1JlLnJlZHVjZSgocmVzdWx0LCBwYXR0ZXJuKSA9PiByZXN1bHQucmVwbGFjZShwYXR0ZXJuLCAnICcpLCBjc3NUZXh0KTtcclxufTtcclxuY29uc3QgbWFrZVNjb3BlTWF0Y2hlciA9IChzY29wZVNlbGVjdG9yKSA9PiB7XHJcbiAgICBjb25zdCBscmUgPSAvXFxbL2c7XHJcbiAgICBjb25zdCBycmUgPSAvXFxdL2c7XHJcbiAgICBzY29wZVNlbGVjdG9yID0gc2NvcGVTZWxlY3Rvci5yZXBsYWNlKGxyZSwgJ1xcXFxbJykucmVwbGFjZShycmUsICdcXFxcXScpO1xyXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14oJyArIHNjb3BlU2VsZWN0b3IgKyAnKScgKyBfc2VsZWN0b3JSZVN1ZmZpeCwgJ20nKTtcclxufTtcclxuY29uc3Qgc2VsZWN0b3JOZWVkc1Njb3BpbmcgPSAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IpID0+IHtcclxuICAgIGNvbnN0IHJlID0gbWFrZVNjb3BlTWF0Y2hlcihzY29wZVNlbGVjdG9yKTtcclxuICAgIHJldHVybiAhcmUudGVzdChzZWxlY3Rvcik7XHJcbn07XHJcbmNvbnN0IGluamVjdFNjb3BpbmdTZWxlY3RvciA9IChzZWxlY3Rvciwgc2NvcGluZ1NlbGVjdG9yKSA9PiB7XHJcbiAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShfc2VsZWN0b3JQYXJ0c1JlLCAoXywgYmVmb3JlID0gJycsIF9jb2xvbkdyb3VwLCBjb2xvbiA9ICcnLCBhZnRlciA9ICcnKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGJlZm9yZSArIHNjb3BpbmdTZWxlY3RvciArIGNvbG9uICsgYWZ0ZXI7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlID0gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpID0+IHtcclxuICAgIC8vIEluIEFuZHJvaWQgYnJvd3NlciwgdGhlIGxhc3RJbmRleCBpcyBub3QgcmVzZXQgd2hlbiB0aGUgcmVnZXggaXMgdXNlZCBpbiBTdHJpbmcucmVwbGFjZSgpXHJcbiAgICBfcG9seWZpbGxIb3N0UmUubGFzdEluZGV4ID0gMDtcclxuICAgIGlmIChfcG9seWZpbGxIb3N0UmUudGVzdChzZWxlY3RvcikpIHtcclxuICAgICAgICBjb25zdCByZXBsYWNlQnkgPSBgLiR7aG9zdFNlbGVjdG9yfWA7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3JSZSwgKF8sIHNlbGVjdG9yKSA9PiBpbmplY3RTY29waW5nU2VsZWN0b3Ioc2VsZWN0b3IsIHJlcGxhY2VCeSkpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgcmVwbGFjZUJ5ICsgJyAnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzY29wZVNlbGVjdG9yICsgJyAnICsgc2VsZWN0b3I7XHJcbn07XHJcbmNvbnN0IGFwcGx5U3RyaWN0U2VsZWN0b3JTY29wZSA9IChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSA9PiB7XHJcbiAgICBjb25zdCBpc1JlID0gL1xcW2lzPShbXlxcXV0qKVxcXS9nO1xyXG4gICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShpc1JlLCAoXywgLi4ucGFydHMpID0+IHBhcnRzWzBdKTtcclxuICAgIGNvbnN0IGNsYXNzTmFtZSA9ICcuJyArIHNjb3BlU2VsZWN0b3I7XHJcbiAgICBjb25zdCBfc2NvcGVTZWxlY3RvclBhcnQgPSAocCkgPT4ge1xyXG4gICAgICAgIGxldCBzY29wZWRQID0gcC50cmltKCk7XHJcbiAgICAgICAgaWYgKCFzY29wZWRQKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHNjb3BlZFAgPSBhcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUocCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSA6aG9zdCBzaW5jZSBpdCBzaG91bGQgYmUgdW5uZWNlc3NhcnlcclxuICAgICAgICAgICAgY29uc3QgdCA9IHAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsICcnKTtcclxuICAgICAgICAgICAgaWYgKHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc2NvcGVkUCA9IGluamVjdFNjb3BpbmdTZWxlY3Rvcih0LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY29wZWRQO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHNhZmVDb250ZW50ID0gc2FmZVNlbGVjdG9yKHNlbGVjdG9yKTtcclxuICAgIHNlbGVjdG9yID0gc2FmZUNvbnRlbnQuY29udGVudDtcclxuICAgIGxldCBzY29wZWRTZWxlY3RvciA9ICcnO1xyXG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xyXG4gICAgbGV0IHJlcztcclxuICAgIGNvbnN0IHNlcCA9IC8oIHw+fFxcK3x+KD8hPSkpXFxzKi9nO1xyXG4gICAgLy8gSWYgYSBzZWxlY3RvciBhcHBlYXJzIGJlZm9yZSA6aG9zdCBpdCBzaG91bGQgbm90IGJlIHNoaW1tZWQgYXMgaXRcclxuICAgIC8vIG1hdGNoZXMgb24gYW5jZXN0b3IgZWxlbWVudHMgYW5kIG5vdCBvbiBlbGVtZW50cyBpbiB0aGUgaG9zdCdzIHNoYWRvd1xyXG4gICAgLy8gYDpob3N0LWNvbnRleHQoZGl2KWAgaXMgdHJhbnNmb3JtZWQgdG9cclxuICAgIC8vIGAtc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yZGl2LCBkaXYgLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcmBcclxuICAgIC8vIHRoZSBgZGl2YCBpcyBub3QgcGFydCBvZiB0aGUgY29tcG9uZW50IGluIHRoZSAybmQgc2VsZWN0b3JzIGFuZCBzaG91bGQgbm90IGJlIHNjb3BlZC5cclxuICAgIC8vIEhpc3RvcmljYWxseSBgY29tcG9uZW50LXRhZzpob3N0YCB3YXMgbWF0Y2hpbmcgdGhlIGNvbXBvbmVudCBzbyB3ZSBhbHNvIHdhbnQgdG8gcHJlc2VydmVcclxuICAgIC8vIHRoaXMgYmVoYXZpb3IgdG8gYXZvaWQgYnJlYWtpbmcgbGVnYWN5IGFwcHMgKGl0IHNob3VsZCBub3QgbWF0Y2gpLlxyXG4gICAgLy8gVGhlIGJlaGF2aW9yIHNob3VsZCBiZTpcclxuICAgIC8vIC0gYHRhZzpob3N0YCAtPiBgdGFnW2hdYCAodGhpcyBpcyB0byBhdm9pZCBicmVha2luZyBsZWdhY3kgYXBwcywgc2hvdWxkIG5vdCBtYXRjaCBhbnl0aGluZylcclxuICAgIC8vIC0gYHRhZyA6aG9zdGAgLT4gYHRhZyBbaF1gIChgdGFnYCBpcyBub3Qgc2NvcGVkIGJlY2F1c2UgaXQncyBjb25zaWRlcmVkIHBhcnQgb2YgYVxyXG4gICAgLy8gICBgOmhvc3QtY29udGV4dCh0YWcpYClcclxuICAgIGNvbnN0IGhhc0hvc3QgPSBzZWxlY3Rvci5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XHJcbiAgICAvLyBPbmx5IHNjb3BlIHBhcnRzIGFmdGVyIHRoZSBmaXJzdCBgLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcmAgd2hlbiBpdCBpcyBwcmVzZW50XHJcbiAgICBsZXQgc2hvdWxkU2NvcGUgPSAhaGFzSG9zdDtcclxuICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IHJlc1sxXTtcclxuICAgICAgICBjb25zdCBwYXJ0ID0gc2VsZWN0b3Iuc2xpY2Uoc3RhcnRJbmRleCwgcmVzLmluZGV4KS50cmltKCk7XHJcbiAgICAgICAgc2hvdWxkU2NvcGUgPSBzaG91bGRTY29wZSB8fCBwYXJ0LmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMTtcclxuICAgICAgICBjb25zdCBzY29wZWRQYXJ0ID0gc2hvdWxkU2NvcGUgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydCkgOiBwYXJ0O1xyXG4gICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IGAke3Njb3BlZFBhcnR9ICR7c2VwYXJhdG9yfSBgO1xyXG4gICAgICAgIHN0YXJ0SW5kZXggPSBzZXAubGFzdEluZGV4O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFydCA9IHNlbGVjdG9yLnN1YnN0cmluZyhzdGFydEluZGV4KTtcclxuICAgIHNob3VsZFNjb3BlID0gc2hvdWxkU2NvcGUgfHwgcGFydC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XHJcbiAgICBzY29wZWRTZWxlY3RvciArPSBzaG91bGRTY29wZSA/IF9zY29wZVNlbGVjdG9yUGFydChwYXJ0KSA6IHBhcnQ7XHJcbiAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlcnMgd2l0aCB0aGVpciBvcmlnaW5hbCB2YWx1ZXNcclxuICAgIHJldHVybiByZXN0b3JlU2FmZVNlbGVjdG9yKHNhZmVDb250ZW50LnBsYWNlaG9sZGVycywgc2NvcGVkU2VsZWN0b3IpO1xyXG59O1xyXG5jb25zdCBzY29wZVNlbGVjdG9yID0gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yVGV4dCwgaG9zdFNlbGVjdG9yLCBzbG90U2VsZWN0b3IpID0+IHtcclxuICAgIHJldHVybiBzZWxlY3RvclxyXG4gICAgICAgIC5zcGxpdCgnLCcpXHJcbiAgICAgICAgLm1hcCgoc2hhbGxvd1BhcnQpID0+IHtcclxuICAgICAgICBpZiAoc2xvdFNlbGVjdG9yICYmIHNoYWxsb3dQYXJ0LmluZGV4T2YoJy4nICsgc2xvdFNlbGVjdG9yKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFsbG93UGFydC50cmltKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWxlY3Rvck5lZWRzU2NvcGluZyhzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvclRleHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHBseVN0cmljdFNlbGVjdG9yU2NvcGUoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3JUZXh0LCBob3N0U2VsZWN0b3IpLnRyaW0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFsbG93UGFydC50cmltKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuICAgICAgICAuam9pbignLCAnKTtcclxufTtcclxuY29uc3Qgc2NvcGVTZWxlY3RvcnMgPSAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvclRleHQsIGhvc3RTZWxlY3Rvciwgc2xvdFNlbGVjdG9yLCBjb21tZW50T3JpZ2luYWxTZWxlY3RvcikgPT4ge1xyXG4gICAgcmV0dXJuIHByb2Nlc3NSdWxlcyhjc3NUZXh0LCAocnVsZSkgPT4ge1xyXG4gICAgICAgIGxldCBzZWxlY3RvciA9IHJ1bGUuc2VsZWN0b3I7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBydWxlLmNvbnRlbnQ7XHJcbiAgICAgICAgaWYgKHJ1bGUuc2VsZWN0b3JbMF0gIT09ICdAJykge1xyXG4gICAgICAgICAgICBzZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IocnVsZS5zZWxlY3Rvciwgc2NvcGVTZWxlY3RvclRleHQsIGhvc3RTZWxlY3Rvciwgc2xvdFNlbGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAbWVkaWEnKSB8fFxyXG4gICAgICAgICAgICBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BzdXBwb3J0cycpIHx8XHJcbiAgICAgICAgICAgIHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHBhZ2UnKSB8fFxyXG4gICAgICAgICAgICBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0Bkb2N1bWVudCcpKSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBzY29wZVNlbGVjdG9ycyhydWxlLmNvbnRlbnQsIHNjb3BlU2VsZWN0b3JUZXh0LCBob3N0U2VsZWN0b3IsIHNsb3RTZWxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNzc1J1bGUgPSB7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3Rvci5yZXBsYWNlKC9cXHN7Mix9L2csICcgJykudHJpbSgpLFxyXG4gICAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGNzc1J1bGU7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3Qgc2NvcGVDc3NUZXh0ID0gKGNzc1RleHQsIHNjb3BlSWQsIGhvc3RTY29wZUlkLCBzbG90U2NvcGVJZCwgY29tbWVudE9yaWdpbmFsU2VsZWN0b3IpID0+IHtcclxuICAgIGNzc1RleHQgPSBpbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQoY3NzVGV4dCk7XHJcbiAgICBjc3NUZXh0ID0gY29udmVydENvbG9uSG9zdChjc3NUZXh0KTtcclxuICAgIGNzc1RleHQgPSBjb252ZXJ0Q29sb25Ib3N0Q29udGV4dChjc3NUZXh0KTtcclxuICAgIGNvbnN0IHNsb3R0ZWQgPSBjb252ZXJ0Q29sb25TbG90dGVkKGNzc1RleHQsIHNsb3RTY29wZUlkKTtcclxuICAgIGNzc1RleHQgPSBzbG90dGVkLmNzc1RleHQ7XHJcbiAgICBjc3NUZXh0ID0gY29udmVydFNoYWRvd0RPTVNlbGVjdG9ycyhjc3NUZXh0KTtcclxuICAgIGlmIChzY29wZUlkKSB7XHJcbiAgICAgICAgY3NzVGV4dCA9IHNjb3BlU2VsZWN0b3JzKGNzc1RleHQsIHNjb3BlSWQsIGhvc3RTY29wZUlkLCBzbG90U2NvcGVJZCk7XHJcbiAgICB9XHJcbiAgICBjc3NUZXh0ID0gcmVwbGFjZVNoYWRvd0Nzc0hvc3QoY3NzVGV4dCwgaG9zdFNjb3BlSWQpO1xyXG4gICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZSgvPlxccypcXCpcXHMrKFteeywgXSspL2dtLCAnICQxICcpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjc3NUZXh0OiBjc3NUZXh0LnRyaW0oKSxcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlcGxhY2UgdGhlIHNoYWRvdyBDU1MgaG9zdCBzdHJpbmcgaW4gZWFjaCBvZiB0aGVzZSBzZWxlY3RvcnMgc2luY2Ugd2UgY3JlYXRlZFxyXG4gICAgICAgIC8vIHRoZW0gcHJpb3IgdG8gdGhlIHJlcGxhY2VtZW50IGhhcHBlbmluZyBpbiB0aGUgY29tcG9uZW50cyBDU1MgdGV4dC5cclxuICAgICAgICBzbG90dGVkU2VsZWN0b3JzOiBzbG90dGVkLnNlbGVjdG9ycy5tYXAoKHJlZikgPT4gKHtcclxuICAgICAgICAgICAgb3JnU2VsZWN0b3I6IHJlcGxhY2VTaGFkb3dDc3NIb3N0KHJlZi5vcmdTZWxlY3RvciwgaG9zdFNjb3BlSWQpLFxyXG4gICAgICAgICAgICB1cGRhdGVkU2VsZWN0b3I6IHJlcGxhY2VTaGFkb3dDc3NIb3N0KHJlZi51cGRhdGVkU2VsZWN0b3IsIGhvc3RTY29wZUlkKSxcclxuICAgICAgICB9KSksXHJcbiAgICB9O1xyXG59O1xyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZXMgdGhlIGludGVyaW0gc3RyaW5nIHJlcHJlc2VudGluZyBhIGA6aG9zdGAgc2VsZWN0b3Igd2l0aFxyXG4gKiB0aGUgaG9zdCBzY29wZSBzZWxlY3RvciBjbGFzcyBmb3IgdGhlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjc3NUZXh0IFRoZSBDU1Mgc3RyaW5nIHRvIG1ha2UgdGhlIHJlcGxhY2VtZW50IGluXHJcbiAqIEBwYXJhbSBob3N0U2NvcGVJZCBUaGUgc2NvcGUgSUQgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGNsYXNzIHJlcHJlc2VudGluZyB0aGUgaG9zdCBlbGVtZW50XHJcbiAqIEByZXR1cm5zIENTUyB3aXRoIHRoZSBzZWxlY3RvciByZXBsYWNlZFxyXG4gKi9cclxuY29uc3QgcmVwbGFjZVNoYWRvd0Nzc0hvc3QgPSAoY3NzVGV4dCwgaG9zdFNjb3BlSWQpID0+IHtcclxuICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoLy1zaGFkb3djc3Nob3N0LW5vLWNvbWJpbmF0b3IvZywgYC4ke2hvc3RTY29wZUlkfWApO1xyXG59O1xyXG5jb25zdCBzY29wZUNzcyA9IChjc3NUZXh0LCBzY29wZUlkLCBjb21tZW50T3JpZ2luYWxTZWxlY3RvcikgPT4ge1xyXG4gICAgY29uc3QgaG9zdFNjb3BlSWQgPSBzY29wZUlkICsgJy1oJztcclxuICAgIGNvbnN0IHNsb3RTY29wZUlkID0gc2NvcGVJZCArICctcyc7XHJcbiAgICBjb25zdCBjb21tZW50c1dpdGhIYXNoID0gZXh0cmFjdENvbW1lbnRzV2l0aEhhc2goY3NzVGV4dCk7XHJcbiAgICBjc3NUZXh0ID0gc3RyaXBDb21tZW50cyhjc3NUZXh0KTtcclxuICAgIGNvbnN0IG9yZ1NlbGVjdG9ycyA9IFtdO1xyXG4gICAgaWYgKGNvbW1lbnRPcmlnaW5hbFNlbGVjdG9yKSB7XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc0NvbW1lbnRlZFNlbGVjdG9yID0gKHJ1bGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBgLyohQF9fXyR7b3JnU2VsZWN0b3JzLmxlbmd0aH1fX18qL2A7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSBgLyohQCR7cnVsZS5zZWxlY3Rvcn0qL2A7XHJcbiAgICAgICAgICAgIG9yZ1NlbGVjdG9ycy5wdXNoKHsgcGxhY2Vob2xkZXIsIGNvbW1lbnQgfSk7XHJcbiAgICAgICAgICAgIHJ1bGUuc2VsZWN0b3IgPSBwbGFjZWhvbGRlciArIHJ1bGUuc2VsZWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBydWxlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY3NzVGV4dCA9IHByb2Nlc3NSdWxlcyhjc3NUZXh0LCAocnVsZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocnVsZS5zZWxlY3RvclswXSAhPT0gJ0AnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0NvbW1lbnRlZFNlbGVjdG9yKHJ1bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQG1lZGlhJykgfHxcclxuICAgICAgICAgICAgICAgIHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHN1cHBvcnRzJykgfHxcclxuICAgICAgICAgICAgICAgIHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHBhZ2UnKSB8fFxyXG4gICAgICAgICAgICAgICAgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAZG9jdW1lbnQnKSkge1xyXG4gICAgICAgICAgICAgICAgcnVsZS5jb250ZW50ID0gcHJvY2Vzc1J1bGVzKHJ1bGUuY29udGVudCwgcHJvY2Vzc0NvbW1lbnRlZFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBydWxlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2NvcGVkID0gc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNjb3BlSWQsIGhvc3RTY29wZUlkLCBzbG90U2NvcGVJZCk7XHJcbiAgICBjc3NUZXh0ID0gW3Njb3BlZC5jc3NUZXh0LCAuLi5jb21tZW50c1dpdGhIYXNoXS5qb2luKCdcXG4nKTtcclxuICAgIGlmIChjb21tZW50T3JpZ2luYWxTZWxlY3Rvcikge1xyXG4gICAgICAgIG9yZ1NlbGVjdG9ycy5mb3JFYWNoKCh7IHBsYWNlaG9sZGVyLCBjb21tZW50IH0pID0+IHtcclxuICAgICAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShwbGFjZWhvbGRlciwgY29tbWVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzY29wZWQuc2xvdHRlZFNlbGVjdG9ycy5mb3JFYWNoKChzbG90dGVkU2VsZWN0b3IpID0+IHtcclxuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwU3BlY2lhbENoYXJhY3RlcnMoc2xvdHRlZFNlbGVjdG9yLm9yZ1NlbGVjdG9yKSwgJ2cnKTtcclxuICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKHJlZ2V4LCBzbG90dGVkU2VsZWN0b3IudXBkYXRlZFNlbGVjdG9yKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNzc1RleHQ7XHJcbn07XHJcblxyXG5leHBvcnQgeyBzY29wZUNzcyB9O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=