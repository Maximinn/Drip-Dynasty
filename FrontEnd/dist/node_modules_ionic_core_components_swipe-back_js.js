"use strict";
(self["webpackChunkfrontend"] = self["webpackChunkfrontend"] || []).push([["node_modules_ionic_core_components_swipe-back_js"],{

/***/ "./node_modules/@ionic/core/components/swipe-back.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ionic/core/components/swipe-back.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSwipeBackGesture: () => (/* binding */ createSwipeBackGesture)
/* harmony export */ });
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/@ionic/core/components/helpers.js");
/* harmony import */ var _dir_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dir.js */ "./node_modules/@ionic/core/components/dir.js");
/* harmony import */ var _index3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index3.js */ "./node_modules/@ionic/core/components/index3.js");
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */




const createSwipeBackGesture = (el, canStartHandler, onStartHandler, onMoveHandler, onEndHandler) => {
    const win = el.ownerDocument.defaultView;
    let rtl = (0,_dir_js__WEBPACK_IMPORTED_MODULE_0__.i)(el);
    /**
     * Determine if a gesture is near the edge
     * of the screen. If true, then the swipe
     * to go back gesture should proceed.
     */
    const isAtEdge = (detail) => {
        const threshold = 50;
        const { startX } = detail;
        if (rtl) {
            return startX >= win.innerWidth - threshold;
        }
        return startX <= threshold;
    };
    const getDeltaX = (detail) => {
        return rtl ? -detail.deltaX : detail.deltaX;
    };
    const getVelocityX = (detail) => {
        return rtl ? -detail.velocityX : detail.velocityX;
    };
    const canStart = (detail) => {
        /**
         * The user's locale can change mid-session,
         * so we need to check text direction at
         * the beginning of every gesture.
         */
        rtl = (0,_dir_js__WEBPACK_IMPORTED_MODULE_0__.i)(el);
        return isAtEdge(detail) && canStartHandler();
    };
    const onMove = (detail) => {
        // set the transition animation's progress
        const delta = getDeltaX(detail);
        const stepValue = delta / win.innerWidth;
        onMoveHandler(stepValue);
    };
    const onEnd = (detail) => {
        // the swipe back gesture has ended
        const delta = getDeltaX(detail);
        const width = win.innerWidth;
        const stepValue = delta / width;
        const velocity = getVelocityX(detail);
        const z = width / 2.0;
        const shouldComplete = velocity >= 0 && (velocity > 0.2 || delta > z);
        const missing = shouldComplete ? 1 - stepValue : stepValue;
        const missingDistance = missing * width;
        let realDur = 0;
        if (missingDistance > 5) {
            const dur = missingDistance / Math.abs(velocity);
            realDur = Math.min(dur, 540);
        }
        onEndHandler(shouldComplete, stepValue <= 0 ? 0.01 : (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.m)(0, stepValue, 0.9999), realDur);
    };
    return (0,_index3_js__WEBPACK_IMPORTED_MODULE_2__.createGesture)({
        el,
        gestureName: 'goback-swipe',
        /**
         * Swipe to go back should have priority over other horizontal swipe
         * gestures. These gestures have a priority of 100 which is why 101 was chosen here.
         */
        gesturePriority: 101,
        threshold: 10,
        canStart,
        onStart: onStartHandler,
        onMove,
        onEnd,
    });
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfY29tcG9uZW50c19zd2lwZS1iYWNrX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDMEM7QUFDSjtBQUNNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMENBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQ0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDhDQUFLO0FBQ2xFO0FBQ0EsV0FBVyx5REFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvc3dpcGUtYmFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHsgbSBhcyBjbGFtcCB9IGZyb20gJy4vaGVscGVycy5qcyc7XHJcbmltcG9ydCB7IGkgYXMgaXNSVEwgfSBmcm9tICcuL2Rpci5qcyc7XHJcbmltcG9ydCB7IGNyZWF0ZUdlc3R1cmUgfSBmcm9tICcuL2luZGV4My5qcyc7XHJcblxyXG5jb25zdCBjcmVhdGVTd2lwZUJhY2tHZXN0dXJlID0gKGVsLCBjYW5TdGFydEhhbmRsZXIsIG9uU3RhcnRIYW5kbGVyLCBvbk1vdmVIYW5kbGVyLCBvbkVuZEhhbmRsZXIpID0+IHtcclxuICAgIGNvbnN0IHdpbiA9IGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICBsZXQgcnRsID0gaXNSVEwoZWwpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmUgaWYgYSBnZXN0dXJlIGlzIG5lYXIgdGhlIGVkZ2VcclxuICAgICAqIG9mIHRoZSBzY3JlZW4uIElmIHRydWUsIHRoZW4gdGhlIHN3aXBlXHJcbiAgICAgKiB0byBnbyBiYWNrIGdlc3R1cmUgc2hvdWxkIHByb2NlZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGlzQXRFZGdlID0gKGRldGFpbCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IDUwO1xyXG4gICAgICAgIGNvbnN0IHsgc3RhcnRYIH0gPSBkZXRhaWw7XHJcbiAgICAgICAgaWYgKHJ0bCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhcnRYID49IHdpbi5pbm5lcldpZHRoIC0gdGhyZXNob2xkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RhcnRYIDw9IHRocmVzaG9sZDtcclxuICAgIH07XHJcbiAgICBjb25zdCBnZXREZWx0YVggPSAoZGV0YWlsKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHJ0bCA/IC1kZXRhaWwuZGVsdGFYIDogZGV0YWlsLmRlbHRhWDtcclxuICAgIH07XHJcbiAgICBjb25zdCBnZXRWZWxvY2l0eVggPSAoZGV0YWlsKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHJ0bCA/IC1kZXRhaWwudmVsb2NpdHlYIDogZGV0YWlsLnZlbG9jaXR5WDtcclxuICAgIH07XHJcbiAgICBjb25zdCBjYW5TdGFydCA9IChkZXRhaWwpID0+IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdXNlcidzIGxvY2FsZSBjYW4gY2hhbmdlIG1pZC1zZXNzaW9uLFxyXG4gICAgICAgICAqIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGV4dCBkaXJlY3Rpb24gYXRcclxuICAgICAgICAgKiB0aGUgYmVnaW5uaW5nIG9mIGV2ZXJ5IGdlc3R1cmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcnRsID0gaXNSVEwoZWwpO1xyXG4gICAgICAgIHJldHVybiBpc0F0RWRnZShkZXRhaWwpICYmIGNhblN0YXJ0SGFuZGxlcigpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9uTW92ZSA9IChkZXRhaWwpID0+IHtcclxuICAgICAgICAvLyBzZXQgdGhlIHRyYW5zaXRpb24gYW5pbWF0aW9uJ3MgcHJvZ3Jlc3NcclxuICAgICAgICBjb25zdCBkZWx0YSA9IGdldERlbHRhWChkZXRhaWwpO1xyXG4gICAgICAgIGNvbnN0IHN0ZXBWYWx1ZSA9IGRlbHRhIC8gd2luLmlubmVyV2lkdGg7XHJcbiAgICAgICAgb25Nb3ZlSGFuZGxlcihzdGVwVmFsdWUpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9uRW5kID0gKGRldGFpbCkgPT4ge1xyXG4gICAgICAgIC8vIHRoZSBzd2lwZSBiYWNrIGdlc3R1cmUgaGFzIGVuZGVkXHJcbiAgICAgICAgY29uc3QgZGVsdGEgPSBnZXREZWx0YVgoZGV0YWlsKTtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHdpbi5pbm5lcldpZHRoO1xyXG4gICAgICAgIGNvbnN0IHN0ZXBWYWx1ZSA9IGRlbHRhIC8gd2lkdGg7XHJcbiAgICAgICAgY29uc3QgdmVsb2NpdHkgPSBnZXRWZWxvY2l0eVgoZGV0YWlsKTtcclxuICAgICAgICBjb25zdCB6ID0gd2lkdGggLyAyLjA7XHJcbiAgICAgICAgY29uc3Qgc2hvdWxkQ29tcGxldGUgPSB2ZWxvY2l0eSA+PSAwICYmICh2ZWxvY2l0eSA+IDAuMiB8fCBkZWx0YSA+IHopO1xyXG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBzaG91bGRDb21wbGV0ZSA/IDEgLSBzdGVwVmFsdWUgOiBzdGVwVmFsdWU7XHJcbiAgICAgICAgY29uc3QgbWlzc2luZ0Rpc3RhbmNlID0gbWlzc2luZyAqIHdpZHRoO1xyXG4gICAgICAgIGxldCByZWFsRHVyID0gMDtcclxuICAgICAgICBpZiAobWlzc2luZ0Rpc3RhbmNlID4gNSkge1xyXG4gICAgICAgICAgICBjb25zdCBkdXIgPSBtaXNzaW5nRGlzdGFuY2UgLyBNYXRoLmFicyh2ZWxvY2l0eSk7XHJcbiAgICAgICAgICAgIHJlYWxEdXIgPSBNYXRoLm1pbihkdXIsIDU0MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9uRW5kSGFuZGxlcihzaG91bGRDb21wbGV0ZSwgc3RlcFZhbHVlIDw9IDAgPyAwLjAxIDogY2xhbXAoMCwgc3RlcFZhbHVlLCAwLjk5OTkpLCByZWFsRHVyKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gY3JlYXRlR2VzdHVyZSh7XHJcbiAgICAgICAgZWwsXHJcbiAgICAgICAgZ2VzdHVyZU5hbWU6ICdnb2JhY2stc3dpcGUnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN3aXBlIHRvIGdvIGJhY2sgc2hvdWxkIGhhdmUgcHJpb3JpdHkgb3ZlciBvdGhlciBob3Jpem9udGFsIHN3aXBlXHJcbiAgICAgICAgICogZ2VzdHVyZXMuIFRoZXNlIGdlc3R1cmVzIGhhdmUgYSBwcmlvcml0eSBvZiAxMDAgd2hpY2ggaXMgd2h5IDEwMSB3YXMgY2hvc2VuIGhlcmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2VzdHVyZVByaW9yaXR5OiAxMDEsXHJcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcclxuICAgICAgICBjYW5TdGFydCxcclxuICAgICAgICBvblN0YXJ0OiBvblN0YXJ0SGFuZGxlcixcclxuICAgICAgICBvbk1vdmUsXHJcbiAgICAgICAgb25FbmQsXHJcbiAgICB9KTtcclxufTtcclxuXHJcbmV4cG9ydCB7IGNyZWF0ZVN3aXBlQmFja0dlc3R1cmUgfTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9