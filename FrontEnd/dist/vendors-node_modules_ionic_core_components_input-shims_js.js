"use strict";
(self["webpackChunkfrontend"] = self["webpackChunkfrontend"] || []).push([["vendors-node_modules_ionic_core_components_input-shims_js"],{

/***/ "./node_modules/@ionic/core/components/input-shims.js":
/*!************************************************************!*\
  !*** ./node_modules/@ionic/core/components/input-shims.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startInputShims: () => (/* binding */ startInputShims)
/* harmony export */ });
/* harmony import */ var _index5_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index5.js */ "./node_modules/@ionic/core/components/index5.js");
/* harmony import */ var _index8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index8.js */ "./node_modules/@ionic/core/components/index8.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/@ionic/core/components/helpers.js");
/* harmony import */ var _keyboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboard.js */ "./node_modules/@ionic/core/components/keyboard.js");
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */





const cloneMap = new WeakMap();
const relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0, disabledClonedInput = false) => {
    if (cloneMap.has(componentEl) === shouldRelocate) {
        return;
    }
    if (shouldRelocate) {
        addClone(componentEl, inputEl, inputRelativeY, disabledClonedInput);
    }
    else {
        removeClone(componentEl, inputEl);
    }
};
const isFocused = (input) => {
    /**
     * https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode
     * Calling getRootNode on an element in standard web page will return HTMLDocument.
     * Calling getRootNode on an element inside of the Shadow DOM will return the associated ShadowRoot.
     * Calling getRootNode on an element that is not attached to a document/shadow tree will return
     * the root of the DOM tree it belongs to.
     * isFocused is used for the hide-caret utility which only considers input/textarea elements
     * that are present in the DOM, so we don't set types for that final case since it does not apply.
     */
    return input === input.getRootNode().activeElement;
};
const addClone = (componentEl, inputEl, inputRelativeY, disabledClonedInput = false) => {
    // this allows for the actual input to receive the focus from
    // the user's touch event, but before it receives focus, it
    // moves the actual input to a location that will not screw
    // up the app's layout, and does not allow the native browser
    // to attempt to scroll the input into place (messing up headers/footers)
    // the cloned input fills the area of where native input should be
    // while the native input fakes out the browser by relocating itself
    // before it receives the actual focus event
    // We hide the focused input (with the visible caret) invisible by making it scale(0),
    const parentEl = inputEl.parentNode;
    // DOM WRITES
    const clonedEl = inputEl.cloneNode(false);
    clonedEl.classList.add('cloned-input');
    clonedEl.tabIndex = -1;
    /**
     * Making the cloned input disabled prevents
     * Chrome for Android from still scrolling
     * the entire page since this cloned input
     * will briefly be hidden by the keyboard
     * even though it is not focused.
     *
     * This is not needed on iOS. While this
     * does not cause functional issues on iOS,
     * the input still appears slightly dimmed even
     * if we set opacity: 1.
     */
    if (disabledClonedInput) {
        clonedEl.disabled = true;
    }
    parentEl.appendChild(clonedEl);
    cloneMap.set(componentEl, clonedEl);
    const doc = componentEl.ownerDocument;
    const tx = doc.dir === 'rtl' ? 9999 : -9999;
    componentEl.style.pointerEvents = 'none';
    inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;
};
const removeClone = (componentEl, inputEl) => {
    const clone = cloneMap.get(componentEl);
    if (clone) {
        cloneMap.delete(componentEl);
        clone.remove();
    }
    componentEl.style.pointerEvents = '';
    inputEl.style.transform = '';
};
/**
 * Factoring in 50px gives us some room
 * in case the keyboard shows password/autofill bars
 * asynchronously.
 */
const SCROLL_AMOUNT_PADDING = 50;

const enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {
    if (!scrollEl || !inputEl) {
        return () => {
            return;
        };
    }
    const scrollHideCaret = (shouldHideCaret) => {
        if (isFocused(inputEl)) {
            relocateInput(componentEl, inputEl, shouldHideCaret);
        }
    };
    const onBlur = () => relocateInput(componentEl, inputEl, false);
    const hideCaret = () => scrollHideCaret(true);
    const showCaret = () => scrollHideCaret(false);
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(scrollEl, 'ionScrollStart', hideCaret);
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(scrollEl, 'ionScrollEnd', showCaret);
    inputEl.addEventListener('blur', onBlur);
    return () => {
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(scrollEl, 'ionScrollStart', hideCaret);
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(scrollEl, 'ionScrollEnd', showCaret);
        inputEl.removeEventListener('blur', onBlur);
    };
};

const SKIP_SELECTOR = 'input, textarea, [no-blur], [contenteditable]';
const enableInputBlurring = () => {
    let focused = true;
    let didScroll = false;
    const doc = document;
    const onScroll = () => {
        didScroll = true;
    };
    const onFocusin = () => {
        focused = true;
    };
    const onTouchend = (ev) => {
        // if app did scroll return early
        if (didScroll) {
            didScroll = false;
            return;
        }
        const active = doc.activeElement;
        if (!active) {
            return;
        }
        // only blur if the active element is a text-input or a textarea
        if (active.matches(SKIP_SELECTOR)) {
            return;
        }
        // if the selected target is the active element, do not blur
        const tapped = ev.target;
        if (tapped === active) {
            return;
        }
        if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {
            return;
        }
        focused = false;
        // TODO FW-2796: find a better way, why 50ms?
        setTimeout(() => {
            if (!focused) {
                active.blur();
            }
        }, 50);
    };
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(doc, 'ionScrollStart', onScroll);
    doc.addEventListener('focusin', onFocusin, true);
    doc.addEventListener('touchend', onTouchend, false);
    return () => {
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(doc, 'ionScrollStart', onScroll, true);
        doc.removeEventListener('focusin', onFocusin, true);
        doc.removeEventListener('touchend', onTouchend, false);
    };
};

const SCROLL_ASSIST_SPEED = 0.3;
const getScrollData = (componentEl, contentEl, keyboardHeight, platformHeight) => {
    var _a;
    const itemEl = (_a = componentEl.closest('ion-item,[ion-item]')) !== null && _a !== void 0 ? _a : componentEl;
    return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, platformHeight);
};
const calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {
    // compute input's Y values relative to the body
    const inputTop = inputRect.top;
    const inputBottom = inputRect.bottom;
    // compute visible area
    const visibleAreaTop = contentRect.top;
    const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);
    // compute safe area
    const safeAreaTop = visibleAreaTop + 15;
    const safeAreaBottom = visibleAreaBottom - SCROLL_AMOUNT_PADDING;
    // figure out if each edge of the input is within the safe area
    const distanceToBottom = safeAreaBottom - inputBottom;
    const distanceToTop = safeAreaTop - inputTop;
    // desiredScrollAmount is the negated distance to the safe area according to our calculations.
    const desiredScrollAmount = Math.round(distanceToBottom < 0 ? -distanceToBottom : distanceToTop > 0 ? -distanceToTop : 0);
    // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input
    // gets focus, so make sure we don't scroll the input above the visible area
    const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);
    const distance = Math.abs(scrollAmount);
    const duration = distance / SCROLL_ASSIST_SPEED;
    const scrollDuration = Math.min(400, Math.max(150, duration));
    return {
        scrollAmount,
        scrollDuration,
        scrollPadding: keyboardHeight,
        inputSafeY: -(inputTop - safeAreaTop) + 4,
    };
};

const PADDING_TIMER_KEY = '$ionPaddingTimer';
/**
 * Scroll padding adds additional padding to the bottom
 * of ion-content so that there is enough scroll space
 * for an input to be scrolled above the keyboard. This
 * is needed in environments where the webview does not
 * resize when the keyboard opens.
 *
 * Example: If an input at the bottom of ion-content is
 * focused, there is no additional scrolling space below
 * it, so the input cannot be scrolled above the keyboard.
 * Scroll padding fixes this by adding padding equal to the
 * height of the keyboard to the bottom of the content.
 *
 * Common environments where this is needed:
 * - Mobile Safari: The keyboard overlays the content
 * - Capacitor/Cordova on iOS: The keyboard overlays the content
 * when the KeyboardResize mode is set to 'none'.
 */
const setScrollPadding = (contentEl, paddingAmount, clearCallback) => {
    const timer = contentEl[PADDING_TIMER_KEY];
    if (timer) {
        clearTimeout(timer);
    }
    if (paddingAmount > 0) {
        contentEl.style.setProperty('--keyboard-offset', `${paddingAmount}px`);
    }
    else {
        contentEl[PADDING_TIMER_KEY] = setTimeout(() => {
            contentEl.style.setProperty('--keyboard-offset', '0px');
            if (clearCallback) {
                clearCallback();
            }
        }, 120);
    }
};
/**
 * When an input is about to be focused,
 * set a timeout to clear any scroll padding
 * on the content. Note: The clearing
 * is done on a timeout so that if users
 * are moving focus from one input to the next
 * then re-adding scroll padding to the new
 * input with cancel the timeout to clear the
 * scroll padding.
 */
const setClearScrollPaddingListener = (inputEl, contentEl, doneCallback) => {
    const clearScrollPadding = () => {
        if (contentEl) {
            setScrollPadding(contentEl, 0, doneCallback);
        }
    };
    inputEl.addEventListener('focusout', clearScrollPadding, { once: true });
};

let currentPadding = 0;
const SKIP_SCROLL_ASSIST = 'data-ionic-skip-scroll-assist';
const enableScrollAssist = (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, keyboardResize, disableClonedInput = false) => {
    /**
     * Scroll padding should only be added if:
     * 1. The global scrollPadding config option
     * is set to true.
     * 2. The native keyboard resize mode is either "none"
     * (keyboard overlays webview) or undefined (resize
     * information unavailable)
     * Resize info is available on Capacitor 4+
     */
    const addScrollPadding = enableScrollPadding && (keyboardResize === undefined || keyboardResize.mode === _keyboard_js__WEBPACK_IMPORTED_MODULE_1__.a.None);
    /**
     * This tracks whether or not the keyboard has been
     * presented for a single focused text field. Note
     * that it does not track if the keyboard is open
     * in general such as if the keyboard is open for
     * a different focused text field.
     */
    let hasKeyboardBeenPresentedForTextField = false;
    /**
     * When adding scroll padding we need to know
     * how much of the viewport the keyboard obscures.
     * We do this by subtracting the keyboard height
     * from the platform height.
     *
     * If we compute this value when switching between
     * inputs then the webview may already be resized.
     * At this point, `win.innerHeight` has already accounted
     * for the keyboard meaning we would then subtract
     * the keyboard height again. This will result in the input
     * being scrolled more than it needs to.
     */
    const platformHeight = _index5_js__WEBPACK_IMPORTED_MODULE_2__.w !== undefined ? _index5_js__WEBPACK_IMPORTED_MODULE_2__.w.innerHeight : 0;
    /**
     * Scroll assist is run when a text field
     * is focused. However, it may need to
     * re-run when the keyboard size changes
     * such that the text field is now hidden
     * underneath the keyboard.
     * This function re-runs scroll assist
     * when that happens.
     *
     * One limitation of this is on a web browser
     * where native keyboard APIs do not have cross-browser
     * support. `ionKeyboardDidShow` relies on the Visual Viewport API.
     * This means that if the keyboard changes but does not change
     * geometry, then scroll assist will not re-run even if
     * the user has scrolled the text field under the keyboard.
     * This is not a problem when running in Cordova/Capacitor
     * because `ionKeyboardDidShow` uses the native events
     * which fire every time the keyboard changes.
     */
    const keyboardShow = (ev) => {
        /**
         * If the keyboard has not yet been presented
         * for this text field then the text field has just
         * received focus. In that case, the focusin listener
         * will run scroll assist.
         */
        if (hasKeyboardBeenPresentedForTextField === false) {
            hasKeyboardBeenPresentedForTextField = true;
            return;
        }
        /**
         * Otherwise, the keyboard has already been presented
         * for the focused text field.
         * This means that the keyboard likely changed
         * geometry, and we need to re-run scroll assist.
         * This can happen when the user rotates their device
         * or when they switch keyboards.
         *
         * Make sure we pass in the computed keyboard height
         * rather than the estimated keyboard height.
         *
         * Since the keyboard is already open then we do not
         * need to wait for the webview to resize, so we pass
         * "waitForResize: false".
         */
        jsSetFocus(componentEl, inputEl, contentEl, footerEl, ev.detail.keyboardHeight, addScrollPadding, disableClonedInput, platformHeight, false);
    };
    /**
     * Reset the internal state when the text field loses focus.
     */
    const focusOut = () => {
        hasKeyboardBeenPresentedForTextField = false;
        _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === null || _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === void 0 ? void 0 : _index5_js__WEBPACK_IMPORTED_MODULE_2__.w.removeEventListener('ionKeyboardDidShow', keyboardShow);
        componentEl.removeEventListener('focusout', focusOut, true);
    };
    /**
     * When the input is about to receive
     * focus, we need to move it to prevent
     * mobile Safari from adjusting the viewport.
     */
    const focusIn = async () => {
        /**
         * Scroll assist should not run again
         * on inputs that have been manually
         * focused inside of the scroll assist
         * implementation.
         */
        if (inputEl.hasAttribute(SKIP_SCROLL_ASSIST)) {
            inputEl.removeAttribute(SKIP_SCROLL_ASSIST);
            return;
        }
        jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight, addScrollPadding, disableClonedInput, platformHeight);
        _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === null || _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === void 0 ? void 0 : _index5_js__WEBPACK_IMPORTED_MODULE_2__.w.addEventListener('ionKeyboardDidShow', keyboardShow);
        componentEl.addEventListener('focusout', focusOut, true);
    };
    componentEl.addEventListener('focusin', focusIn, true);
    return () => {
        componentEl.removeEventListener('focusin', focusIn, true);
        _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === null || _index5_js__WEBPACK_IMPORTED_MODULE_2__.w === void 0 ? void 0 : _index5_js__WEBPACK_IMPORTED_MODULE_2__.w.removeEventListener('ionKeyboardDidShow', keyboardShow);
        componentEl.removeEventListener('focusout', focusOut, true);
    };
};
/**
 * Use this function when you want to manually
 * focus an input but not have scroll assist run again.
 */
const setManualFocus = (el) => {
    /**
     * If element is already focused then
     * a new focusin event will not be dispatched
     * to remove the SKIL_SCROLL_ASSIST attribute.
     */
    if (document.activeElement === el) {
        return;
    }
    el.setAttribute(SKIP_SCROLL_ASSIST, 'true');
    el.focus();
};
const jsSetFocus = async (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, disableClonedInput = false, platformHeight = 0, waitForResize = true) => {
    if (!contentEl && !footerEl) {
        return;
    }
    const scrollData = getScrollData(componentEl, (contentEl || footerEl), keyboardHeight, platformHeight);
    if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {
        // the text input is in a safe position that doesn't
        // require it to be scrolled into view, just set focus now
        setManualFocus(inputEl);
        /**
         * Even though the input does not need
         * scroll assist, we should preserve the
         * the scroll padding as users could be moving
         * focus from an input that needs scroll padding
         * to an input that does not need scroll padding.
         * If we remove the scroll padding now, users will
         * see the page jump.
         */
        if (enableScrollPadding && contentEl !== null) {
            setScrollPadding(contentEl, currentPadding);
            setClearScrollPaddingListener(inputEl, contentEl, () => (currentPadding = 0));
        }
        return;
    }
    // temporarily move the focus to the focus holder so the browser
    // doesn't freak out while it's trying to get the input in place
    // at this point the native text input still does not have focus
    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY, disableClonedInput);
    setManualFocus(inputEl);
    /**
     * Relocating/Focusing input causes the
     * click event to be cancelled, so
     * manually fire one here.
     */
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => componentEl.click());
    /**
     * If enabled, we can add scroll padding to
     * the bottom of the content so that scroll assist
     * has enough room to scroll the input above
     * the keyboard.
     */
    if (enableScrollPadding && contentEl) {
        currentPadding = scrollData.scrollPadding;
        setScrollPadding(contentEl, currentPadding);
    }
    if (typeof window !== 'undefined') {
        let scrollContentTimeout;
        const scrollContent = async () => {
            // clean up listeners and timeouts
            if (scrollContentTimeout !== undefined) {
                clearTimeout(scrollContentTimeout);
            }
            window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
            window.removeEventListener('ionKeyboardDidShow', scrollContent);
            // scroll the input into place
            if (contentEl) {
                await (0,_index8_js__WEBPACK_IMPORTED_MODULE_3__.c)(contentEl, 0, scrollData.scrollAmount, scrollData.scrollDuration);
            }
            // the scroll view is in the correct position now
            // give the native text input focus
            relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);
            // ensure this is the focused input
            setManualFocus(inputEl);
            /**
             * When the input is about to be blurred
             * we should set a timeout to remove
             * any scroll padding.
             */
            if (enableScrollPadding) {
                setClearScrollPaddingListener(inputEl, contentEl, () => (currentPadding = 0));
            }
        };
        const doubleKeyboardEventListener = () => {
            window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
            window.addEventListener('ionKeyboardDidShow', scrollContent);
        };
        if (contentEl) {
            const scrollEl = await (0,_index8_js__WEBPACK_IMPORTED_MODULE_3__.g)(contentEl);
            /**
             * scrollData will only consider the amount we need
             * to scroll in order to properly bring the input
             * into view. It will not consider the amount
             * we can scroll in the content element.
             * As a result, scrollData may request a greater
             * scroll position than is currently available
             * in the DOM. If this is the case, we need to
             * wait for the webview to resize/the keyboard
             * to show in order for additional scroll
             * bandwidth to become available.
             */
            const totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;
            if (waitForResize && scrollData.scrollAmount > totalScrollAmount - scrollEl.scrollTop) {
                /**
                 * On iOS devices, the system will show a "Passwords" bar above the keyboard
                 * after the initial keyboard is shown. This prevents the webview from resizing
                 * until the "Passwords" bar is shown, so we need to wait for that to happen first.
                 */
                if (inputEl.type === 'password') {
                    // Add 50px to account for the "Passwords" bar
                    scrollData.scrollAmount += SCROLL_AMOUNT_PADDING;
                    window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
                }
                else {
                    window.addEventListener('ionKeyboardDidShow', scrollContent);
                }
                /**
                 * This should only fire in 2 instances:
                 * 1. The app is very slow.
                 * 2. The app is running in a browser on an old OS
                 * that does not support Ionic Keyboard Events
                 */
                scrollContentTimeout = setTimeout(scrollContent, 1000);
                return;
            }
        }
        scrollContent();
    }
};

const INPUT_BLURRING = true;
const startInputShims = async (config, platform) => {
    /**
     * If doc is undefined then we are in an SSR environment
     * where input shims do not apply.
     */
    if (_index5_js__WEBPACK_IMPORTED_MODULE_2__.d === undefined) {
        return;
    }
    const isIOS = platform === 'ios';
    const isAndroid = platform === 'android';
    /**
     * Hide Caret and Input Blurring are needed on iOS.
     * Scroll Assist and Scroll Padding are needed on iOS and Android
     * with Chrome web browser (not Chrome webview).
     */
    const keyboardHeight = config.getNumber('keyboardHeight', 290);
    const scrollAssist = config.getBoolean('scrollAssist', true);
    const hideCaret = config.getBoolean('hideCaretOnScroll', isIOS);
    const inputBlurring = config.getBoolean('inputBlurring', isIOS);
    const scrollPadding = config.getBoolean('scrollPadding', true);
    const inputs = Array.from(_index5_js__WEBPACK_IMPORTED_MODULE_2__.d.querySelectorAll('ion-input, ion-textarea'));
    const hideCaretMap = new WeakMap();
    const scrollAssistMap = new WeakMap();
    /**
     * Grab the native keyboard resize configuration
     * and pass it to scroll assist. Scroll assist requires
     * that we adjust the input right before the input
     * is about to be focused. If we called `Keyboard.getResizeMode`
     * on focusin in scroll assist, we could potentially adjust the
     * input too late since this call is async.
     */
    const keyboardResizeMode = await _keyboard_js__WEBPACK_IMPORTED_MODULE_1__.K.getResizeMode();
    const registerInput = async (componentEl) => {
        await new Promise((resolve) => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.c)(componentEl, resolve));
        const inputRoot = componentEl.shadowRoot || componentEl;
        const inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');
        const scrollEl = (0,_index8_js__WEBPACK_IMPORTED_MODULE_3__.a)(componentEl);
        const footerEl = !scrollEl ? componentEl.closest('ion-footer') : null;
        if (!inputEl) {
            return;
        }
        if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {
            const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);
            hideCaretMap.set(componentEl, rmFn);
        }
        /**
         * date/datetime-locale inputs on mobile devices show date picker
         * overlays instead of keyboards. As a result, scroll assist is
         * not needed. This also works around a bug in iOS <16 where
         * scroll assist causes the browser to lock up. See FW-1997.
         */
        const isDateInput = inputEl.type === 'date' || inputEl.type === 'datetime-local';
        if (!isDateInput &&
            (!!scrollEl || !!footerEl) &&
            scrollAssist &&
            !scrollAssistMap.has(componentEl)) {
            const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight, scrollPadding, keyboardResizeMode, isAndroid);
            scrollAssistMap.set(componentEl, rmFn);
        }
    };
    const unregisterInput = (componentEl) => {
        if (hideCaret) {
            const fn = hideCaretMap.get(componentEl);
            if (fn) {
                fn();
            }
            hideCaretMap.delete(componentEl);
        }
        if (scrollAssist) {
            const fn = scrollAssistMap.get(componentEl);
            if (fn) {
                fn();
            }
            scrollAssistMap.delete(componentEl);
        }
    };
    if (inputBlurring && INPUT_BLURRING) {
        enableInputBlurring();
    }
    // Input might be already loaded in the DOM before ion-device-hacks did.
    // At this point we need to look for all of the inputs not registered yet
    // and register them.
    for (const input of inputs) {
        registerInput(input);
    }
    _index5_js__WEBPACK_IMPORTED_MODULE_2__.d.addEventListener('ionInputDidLoad', (ev) => {
        registerInput(ev.detail);
    });
    _index5_js__WEBPACK_IMPORTED_MODULE_2__.d.addEventListener('ionInputDidUnload', (ev) => {
        unregisterInput(ev.detail);
    });
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9jb21wb25lbnRzX2lucHV0LXNoaW1zX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ2lEO0FBQ21EO0FBQ1k7QUFDN0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEdBQUcsS0FBSyxlQUFlO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4Q0FBZ0I7QUFDcEIsSUFBSSw4Q0FBZ0I7QUFDcEI7QUFDQTtBQUNBLFFBQVEsOENBQW1CO0FBQzNCLFFBQVEsOENBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsSUFBSSw4Q0FBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxjQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxZQUFZO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsMkNBQWM7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlDQUFHLGlCQUFpQix5Q0FBRztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQUcsYUFBYSx5Q0FBRyx1QkFBdUIseUNBQUc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUFHLGFBQWEseUNBQUcsdUJBQXVCLHlDQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUFHLGFBQWEseUNBQUcsdUJBQXVCLHlDQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDhDQUFHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkNBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBRztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyQ0FBUTtBQUM3QztBQUNBLHVDQUF1Qyw4Q0FBZ0I7QUFDdkQ7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5Q0FBRztBQUNQO0FBQ0EsS0FBSztBQUNMLElBQUkseUNBQUc7QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQzJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9pbnB1dC1zaGltcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHsgdyBhcyB3aW4sIGQgYXMgZG9jIH0gZnJvbSAnLi9pbmRleDUuanMnO1xyXG5pbXBvcnQgeyBnIGFzIGdldFNjcm9sbEVsZW1lbnQsIGMgYXMgc2Nyb2xsQnlQb2ludCwgYSBhcyBmaW5kQ2xvc2VzdElvbkNvbnRlbnQgfSBmcm9tICcuL2luZGV4OC5qcyc7XHJcbmltcG9ydCB7IGEgYXMgYWRkRXZlbnRMaXN0ZW5lciwgYiBhcyByZW1vdmVFdmVudExpc3RlbmVyLCByIGFzIHJhZiwgYyBhcyBjb21wb25lbnRPblJlYWR5IH0gZnJvbSAnLi9oZWxwZXJzLmpzJztcclxuaW1wb3J0IHsgYSBhcyBLZXlib2FyZFJlc2l6ZSwgSyBhcyBLZXlib2FyZCB9IGZyb20gJy4va2V5Ym9hcmQuanMnO1xyXG5cclxuY29uc3QgY2xvbmVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCByZWxvY2F0ZUlucHV0ID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzaG91bGRSZWxvY2F0ZSwgaW5wdXRSZWxhdGl2ZVkgPSAwLCBkaXNhYmxlZENsb25lZElucHV0ID0gZmFsc2UpID0+IHtcclxuICAgIGlmIChjbG9uZU1hcC5oYXMoY29tcG9uZW50RWwpID09PSBzaG91bGRSZWxvY2F0ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChzaG91bGRSZWxvY2F0ZSkge1xyXG4gICAgICAgIGFkZENsb25lKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBpbnB1dFJlbGF0aXZlWSwgZGlzYWJsZWRDbG9uZWRJbnB1dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZW1vdmVDbG9uZShjb21wb25lbnRFbCwgaW5wdXRFbCk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGlzRm9jdXNlZCA9IChpbnB1dCkgPT4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9nZXRSb290Tm9kZVxyXG4gICAgICogQ2FsbGluZyBnZXRSb290Tm9kZSBvbiBhbiBlbGVtZW50IGluIHN0YW5kYXJkIHdlYiBwYWdlIHdpbGwgcmV0dXJuIEhUTUxEb2N1bWVudC5cclxuICAgICAqIENhbGxpbmcgZ2V0Um9vdE5vZGUgb24gYW4gZWxlbWVudCBpbnNpZGUgb2YgdGhlIFNoYWRvdyBET00gd2lsbCByZXR1cm4gdGhlIGFzc29jaWF0ZWQgU2hhZG93Um9vdC5cclxuICAgICAqIENhbGxpbmcgZ2V0Um9vdE5vZGUgb24gYW4gZWxlbWVudCB0aGF0IGlzIG5vdCBhdHRhY2hlZCB0byBhIGRvY3VtZW50L3NoYWRvdyB0cmVlIHdpbGwgcmV0dXJuXHJcbiAgICAgKiB0aGUgcm9vdCBvZiB0aGUgRE9NIHRyZWUgaXQgYmVsb25ncyB0by5cclxuICAgICAqIGlzRm9jdXNlZCBpcyB1c2VkIGZvciB0aGUgaGlkZS1jYXJldCB1dGlsaXR5IHdoaWNoIG9ubHkgY29uc2lkZXJzIGlucHV0L3RleHRhcmVhIGVsZW1lbnRzXHJcbiAgICAgKiB0aGF0IGFyZSBwcmVzZW50IGluIHRoZSBET00sIHNvIHdlIGRvbid0IHNldCB0eXBlcyBmb3IgdGhhdCBmaW5hbCBjYXNlIHNpbmNlIGl0IGRvZXMgbm90IGFwcGx5LlxyXG4gICAgICovXHJcbiAgICByZXR1cm4gaW5wdXQgPT09IGlucHV0LmdldFJvb3ROb2RlKCkuYWN0aXZlRWxlbWVudDtcclxufTtcclxuY29uc3QgYWRkQ2xvbmUgPSAoY29tcG9uZW50RWwsIGlucHV0RWwsIGlucHV0UmVsYXRpdmVZLCBkaXNhYmxlZENsb25lZElucHV0ID0gZmFsc2UpID0+IHtcclxuICAgIC8vIHRoaXMgYWxsb3dzIGZvciB0aGUgYWN0dWFsIGlucHV0IHRvIHJlY2VpdmUgdGhlIGZvY3VzIGZyb21cclxuICAgIC8vIHRoZSB1c2VyJ3MgdG91Y2ggZXZlbnQsIGJ1dCBiZWZvcmUgaXQgcmVjZWl2ZXMgZm9jdXMsIGl0XHJcbiAgICAvLyBtb3ZlcyB0aGUgYWN0dWFsIGlucHV0IHRvIGEgbG9jYXRpb24gdGhhdCB3aWxsIG5vdCBzY3Jld1xyXG4gICAgLy8gdXAgdGhlIGFwcCdzIGxheW91dCwgYW5kIGRvZXMgbm90IGFsbG93IHRoZSBuYXRpdmUgYnJvd3NlclxyXG4gICAgLy8gdG8gYXR0ZW1wdCB0byBzY3JvbGwgdGhlIGlucHV0IGludG8gcGxhY2UgKG1lc3NpbmcgdXAgaGVhZGVycy9mb290ZXJzKVxyXG4gICAgLy8gdGhlIGNsb25lZCBpbnB1dCBmaWxscyB0aGUgYXJlYSBvZiB3aGVyZSBuYXRpdmUgaW5wdXQgc2hvdWxkIGJlXHJcbiAgICAvLyB3aGlsZSB0aGUgbmF0aXZlIGlucHV0IGZha2VzIG91dCB0aGUgYnJvd3NlciBieSByZWxvY2F0aW5nIGl0c2VsZlxyXG4gICAgLy8gYmVmb3JlIGl0IHJlY2VpdmVzIHRoZSBhY3R1YWwgZm9jdXMgZXZlbnRcclxuICAgIC8vIFdlIGhpZGUgdGhlIGZvY3VzZWQgaW5wdXQgKHdpdGggdGhlIHZpc2libGUgY2FyZXQpIGludmlzaWJsZSBieSBtYWtpbmcgaXQgc2NhbGUoMCksXHJcbiAgICBjb25zdCBwYXJlbnRFbCA9IGlucHV0RWwucGFyZW50Tm9kZTtcclxuICAgIC8vIERPTSBXUklURVNcclxuICAgIGNvbnN0IGNsb25lZEVsID0gaW5wdXRFbC5jbG9uZU5vZGUoZmFsc2UpO1xyXG4gICAgY2xvbmVkRWwuY2xhc3NMaXN0LmFkZCgnY2xvbmVkLWlucHV0Jyk7XHJcbiAgICBjbG9uZWRFbC50YWJJbmRleCA9IC0xO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtpbmcgdGhlIGNsb25lZCBpbnB1dCBkaXNhYmxlZCBwcmV2ZW50c1xyXG4gICAgICogQ2hyb21lIGZvciBBbmRyb2lkIGZyb20gc3RpbGwgc2Nyb2xsaW5nXHJcbiAgICAgKiB0aGUgZW50aXJlIHBhZ2Ugc2luY2UgdGhpcyBjbG9uZWQgaW5wdXRcclxuICAgICAqIHdpbGwgYnJpZWZseSBiZSBoaWRkZW4gYnkgdGhlIGtleWJvYXJkXHJcbiAgICAgKiBldmVuIHRob3VnaCBpdCBpcyBub3QgZm9jdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIG5vdCBuZWVkZWQgb24gaU9TLiBXaGlsZSB0aGlzXHJcbiAgICAgKiBkb2VzIG5vdCBjYXVzZSBmdW5jdGlvbmFsIGlzc3VlcyBvbiBpT1MsXHJcbiAgICAgKiB0aGUgaW5wdXQgc3RpbGwgYXBwZWFycyBzbGlnaHRseSBkaW1tZWQgZXZlblxyXG4gICAgICogaWYgd2Ugc2V0IG9wYWNpdHk6IDEuXHJcbiAgICAgKi9cclxuICAgIGlmIChkaXNhYmxlZENsb25lZElucHV0KSB7XHJcbiAgICAgICAgY2xvbmVkRWwuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQoY2xvbmVkRWwpO1xyXG4gICAgY2xvbmVNYXAuc2V0KGNvbXBvbmVudEVsLCBjbG9uZWRFbCk7XHJcbiAgICBjb25zdCBkb2MgPSBjb21wb25lbnRFbC5vd25lckRvY3VtZW50O1xyXG4gICAgY29uc3QgdHggPSBkb2MuZGlyID09PSAncnRsJyA/IDk5OTkgOiAtOTk5OTtcclxuICAgIGNvbXBvbmVudEVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcbiAgICBpbnB1dEVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3R4fXB4LCR7aW5wdXRSZWxhdGl2ZVl9cHgsMCkgc2NhbGUoMClgO1xyXG59O1xyXG5jb25zdCByZW1vdmVDbG9uZSA9IChjb21wb25lbnRFbCwgaW5wdXRFbCkgPT4ge1xyXG4gICAgY29uc3QgY2xvbmUgPSBjbG9uZU1hcC5nZXQoY29tcG9uZW50RWwpO1xyXG4gICAgaWYgKGNsb25lKSB7XHJcbiAgICAgICAgY2xvbmVNYXAuZGVsZXRlKGNvbXBvbmVudEVsKTtcclxuICAgICAgICBjbG9uZS5yZW1vdmUoKTtcclxuICAgIH1cclxuICAgIGNvbXBvbmVudEVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcclxuICAgIGlucHV0RWwuc3R5bGUudHJhbnNmb3JtID0gJyc7XHJcbn07XHJcbi8qKlxyXG4gKiBGYWN0b3JpbmcgaW4gNTBweCBnaXZlcyB1cyBzb21lIHJvb21cclxuICogaW4gY2FzZSB0aGUga2V5Ym9hcmQgc2hvd3MgcGFzc3dvcmQvYXV0b2ZpbGwgYmFyc1xyXG4gKiBhc3luY2hyb25vdXNseS5cclxuICovXHJcbmNvbnN0IFNDUk9MTF9BTU9VTlRfUEFERElORyA9IDUwO1xyXG5cclxuY29uc3QgZW5hYmxlSGlkZUNhcmV0T25TY3JvbGwgPSAoY29tcG9uZW50RWwsIGlucHV0RWwsIHNjcm9sbEVsKSA9PiB7XHJcbiAgICBpZiAoIXNjcm9sbEVsIHx8ICFpbnB1dEVsKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBzY3JvbGxIaWRlQ2FyZXQgPSAoc2hvdWxkSGlkZUNhcmV0KSA9PiB7XHJcbiAgICAgICAgaWYgKGlzRm9jdXNlZChpbnB1dEVsKSkge1xyXG4gICAgICAgICAgICByZWxvY2F0ZUlucHV0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzaG91bGRIaWRlQ2FyZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBvbkJsdXIgPSAoKSA9PiByZWxvY2F0ZUlucHV0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCBmYWxzZSk7XHJcbiAgICBjb25zdCBoaWRlQ2FyZXQgPSAoKSA9PiBzY3JvbGxIaWRlQ2FyZXQodHJ1ZSk7XHJcbiAgICBjb25zdCBzaG93Q2FyZXQgPSAoKSA9PiBzY3JvbGxIaWRlQ2FyZXQoZmFsc2UpO1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihzY3JvbGxFbCwgJ2lvblNjcm9sbFN0YXJ0JywgaGlkZUNhcmV0KTtcclxuICAgIGFkZEV2ZW50TGlzdGVuZXIoc2Nyb2xsRWwsICdpb25TY3JvbGxFbmQnLCBzaG93Q2FyZXQpO1xyXG4gICAgaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgb25CbHVyKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihzY3JvbGxFbCwgJ2lvblNjcm9sbFN0YXJ0JywgaGlkZUNhcmV0KTtcclxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHNjcm9sbEVsLCAnaW9uU2Nyb2xsRW5kJywgc2hvd0NhcmV0KTtcclxuICAgICAgICBpbnB1dEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xyXG4gICAgfTtcclxufTtcclxuXHJcbmNvbnN0IFNLSVBfU0VMRUNUT1IgPSAnaW5wdXQsIHRleHRhcmVhLCBbbm8tYmx1cl0sIFtjb250ZW50ZWRpdGFibGVdJztcclxuY29uc3QgZW5hYmxlSW5wdXRCbHVycmluZyA9ICgpID0+IHtcclxuICAgIGxldCBmb2N1c2VkID0gdHJ1ZTtcclxuICAgIGxldCBkaWRTY3JvbGwgPSBmYWxzZTtcclxuICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50O1xyXG4gICAgY29uc3Qgb25TY3JvbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgZGlkU2Nyb2xsID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBvbkZvY3VzaW4gPSAoKSA9PiB7XHJcbiAgICAgICAgZm9jdXNlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb25Ub3VjaGVuZCA9IChldikgPT4ge1xyXG4gICAgICAgIC8vIGlmIGFwcCBkaWQgc2Nyb2xsIHJldHVybiBlYXJseVxyXG4gICAgICAgIGlmIChkaWRTY3JvbGwpIHtcclxuICAgICAgICAgICAgZGlkU2Nyb2xsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWN0aXZlID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFhY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvbmx5IGJsdXIgaWYgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIGEgdGV4dC1pbnB1dCBvciBhIHRleHRhcmVhXHJcbiAgICAgICAgaWYgKGFjdGl2ZS5tYXRjaGVzKFNLSVBfU0VMRUNUT1IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHNlbGVjdGVkIHRhcmdldCBpcyB0aGUgYWN0aXZlIGVsZW1lbnQsIGRvIG5vdCBibHVyXHJcbiAgICAgICAgY29uc3QgdGFwcGVkID0gZXYudGFyZ2V0O1xyXG4gICAgICAgIGlmICh0YXBwZWQgPT09IGFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXBwZWQubWF0Y2hlcyhTS0lQX1NFTEVDVE9SKSB8fCB0YXBwZWQuY2xvc2VzdChTS0lQX1NFTEVDVE9SKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvY3VzZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBUT0RPIEZXLTI3OTY6IGZpbmQgYSBiZXR0ZXIgd2F5LCB3aHkgNTBtcz9cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFmb2N1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmUuYmx1cigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgNTApO1xyXG4gICAgfTtcclxuICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9jLCAnaW9uU2Nyb2xsU3RhcnQnLCBvblNjcm9sbCk7XHJcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXNpbiwgdHJ1ZSk7XHJcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kLCBmYWxzZSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jLCAnaW9uU2Nyb2xsU3RhcnQnLCBvblNjcm9sbCwgdHJ1ZSk7XHJcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzaW4sIHRydWUpO1xyXG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hlbmQsIGZhbHNlKTtcclxuICAgIH07XHJcbn07XHJcblxyXG5jb25zdCBTQ1JPTExfQVNTSVNUX1NQRUVEID0gMC4zO1xyXG5jb25zdCBnZXRTY3JvbGxEYXRhID0gKGNvbXBvbmVudEVsLCBjb250ZW50RWwsIGtleWJvYXJkSGVpZ2h0LCBwbGF0Zm9ybUhlaWdodCkgPT4ge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgaXRlbUVsID0gKF9hID0gY29tcG9uZW50RWwuY2xvc2VzdCgnaW9uLWl0ZW0sW2lvbi1pdGVtXScpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb21wb25lbnRFbDtcclxuICAgIHJldHVybiBjYWxjU2Nyb2xsRGF0YShpdGVtRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGNvbnRlbnRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwga2V5Ym9hcmRIZWlnaHQsIHBsYXRmb3JtSGVpZ2h0KTtcclxufTtcclxuY29uc3QgY2FsY1Njcm9sbERhdGEgPSAoaW5wdXRSZWN0LCBjb250ZW50UmVjdCwga2V5Ym9hcmRIZWlnaHQsIHBsYXRmb3JtSGVpZ2h0KSA9PiB7XHJcbiAgICAvLyBjb21wdXRlIGlucHV0J3MgWSB2YWx1ZXMgcmVsYXRpdmUgdG8gdGhlIGJvZHlcclxuICAgIGNvbnN0IGlucHV0VG9wID0gaW5wdXRSZWN0LnRvcDtcclxuICAgIGNvbnN0IGlucHV0Qm90dG9tID0gaW5wdXRSZWN0LmJvdHRvbTtcclxuICAgIC8vIGNvbXB1dGUgdmlzaWJsZSBhcmVhXHJcbiAgICBjb25zdCB2aXNpYmxlQXJlYVRvcCA9IGNvbnRlbnRSZWN0LnRvcDtcclxuICAgIGNvbnN0IHZpc2libGVBcmVhQm90dG9tID0gTWF0aC5taW4oY29udGVudFJlY3QuYm90dG9tLCBwbGF0Zm9ybUhlaWdodCAtIGtleWJvYXJkSGVpZ2h0KTtcclxuICAgIC8vIGNvbXB1dGUgc2FmZSBhcmVhXHJcbiAgICBjb25zdCBzYWZlQXJlYVRvcCA9IHZpc2libGVBcmVhVG9wICsgMTU7XHJcbiAgICBjb25zdCBzYWZlQXJlYUJvdHRvbSA9IHZpc2libGVBcmVhQm90dG9tIC0gU0NST0xMX0FNT1VOVF9QQURESU5HO1xyXG4gICAgLy8gZmlndXJlIG91dCBpZiBlYWNoIGVkZ2Ugb2YgdGhlIGlucHV0IGlzIHdpdGhpbiB0aGUgc2FmZSBhcmVhXHJcbiAgICBjb25zdCBkaXN0YW5jZVRvQm90dG9tID0gc2FmZUFyZWFCb3R0b20gLSBpbnB1dEJvdHRvbTtcclxuICAgIGNvbnN0IGRpc3RhbmNlVG9Ub3AgPSBzYWZlQXJlYVRvcCAtIGlucHV0VG9wO1xyXG4gICAgLy8gZGVzaXJlZFNjcm9sbEFtb3VudCBpcyB0aGUgbmVnYXRlZCBkaXN0YW5jZSB0byB0aGUgc2FmZSBhcmVhIGFjY29yZGluZyB0byBvdXIgY2FsY3VsYXRpb25zLlxyXG4gICAgY29uc3QgZGVzaXJlZFNjcm9sbEFtb3VudCA9IE1hdGgucm91bmQoZGlzdGFuY2VUb0JvdHRvbSA8IDAgPyAtZGlzdGFuY2VUb0JvdHRvbSA6IGRpc3RhbmNlVG9Ub3AgPiAwID8gLWRpc3RhbmNlVG9Ub3AgOiAwKTtcclxuICAgIC8vIG91ciBjYWxjdWxhdGlvbnMgbWFrZSBzb21lIGFzc3VtcHRpb25zIHRoYXQgYXJlbid0IGFsd2F5cyB0cnVlLCBsaWtlIHRoZSBrZXlib2FyZCBiZWluZyBjbG9zZWQgd2hlbiBhbiBpbnB1dFxyXG4gICAgLy8gZ2V0cyBmb2N1cywgc28gbWFrZSBzdXJlIHdlIGRvbid0IHNjcm9sbCB0aGUgaW5wdXQgYWJvdmUgdGhlIHZpc2libGUgYXJlYVxyXG4gICAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gTWF0aC5taW4oZGVzaXJlZFNjcm9sbEFtb3VudCwgaW5wdXRUb3AgLSB2aXNpYmxlQXJlYVRvcCk7XHJcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguYWJzKHNjcm9sbEFtb3VudCk7XHJcbiAgICBjb25zdCBkdXJhdGlvbiA9IGRpc3RhbmNlIC8gU0NST0xMX0FTU0lTVF9TUEVFRDtcclxuICAgIGNvbnN0IHNjcm9sbER1cmF0aW9uID0gTWF0aC5taW4oNDAwLCBNYXRoLm1heCgxNTAsIGR1cmF0aW9uKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNjcm9sbEFtb3VudCxcclxuICAgICAgICBzY3JvbGxEdXJhdGlvbixcclxuICAgICAgICBzY3JvbGxQYWRkaW5nOiBrZXlib2FyZEhlaWdodCxcclxuICAgICAgICBpbnB1dFNhZmVZOiAtKGlucHV0VG9wIC0gc2FmZUFyZWFUb3ApICsgNCxcclxuICAgIH07XHJcbn07XHJcblxyXG5jb25zdCBQQURESU5HX1RJTUVSX0tFWSA9ICckaW9uUGFkZGluZ1RpbWVyJztcclxuLyoqXHJcbiAqIFNjcm9sbCBwYWRkaW5nIGFkZHMgYWRkaXRpb25hbCBwYWRkaW5nIHRvIHRoZSBib3R0b21cclxuICogb2YgaW9uLWNvbnRlbnQgc28gdGhhdCB0aGVyZSBpcyBlbm91Z2ggc2Nyb2xsIHNwYWNlXHJcbiAqIGZvciBhbiBpbnB1dCB0byBiZSBzY3JvbGxlZCBhYm92ZSB0aGUga2V5Ym9hcmQuIFRoaXNcclxuICogaXMgbmVlZGVkIGluIGVudmlyb25tZW50cyB3aGVyZSB0aGUgd2VidmlldyBkb2VzIG5vdFxyXG4gKiByZXNpemUgd2hlbiB0aGUga2V5Ym9hcmQgb3BlbnMuXHJcbiAqXHJcbiAqIEV4YW1wbGU6IElmIGFuIGlucHV0IGF0IHRoZSBib3R0b20gb2YgaW9uLWNvbnRlbnQgaXNcclxuICogZm9jdXNlZCwgdGhlcmUgaXMgbm8gYWRkaXRpb25hbCBzY3JvbGxpbmcgc3BhY2UgYmVsb3dcclxuICogaXQsIHNvIHRoZSBpbnB1dCBjYW5ub3QgYmUgc2Nyb2xsZWQgYWJvdmUgdGhlIGtleWJvYXJkLlxyXG4gKiBTY3JvbGwgcGFkZGluZyBmaXhlcyB0aGlzIGJ5IGFkZGluZyBwYWRkaW5nIGVxdWFsIHRvIHRoZVxyXG4gKiBoZWlnaHQgb2YgdGhlIGtleWJvYXJkIHRvIHRoZSBib3R0b20gb2YgdGhlIGNvbnRlbnQuXHJcbiAqXHJcbiAqIENvbW1vbiBlbnZpcm9ubWVudHMgd2hlcmUgdGhpcyBpcyBuZWVkZWQ6XHJcbiAqIC0gTW9iaWxlIFNhZmFyaTogVGhlIGtleWJvYXJkIG92ZXJsYXlzIHRoZSBjb250ZW50XHJcbiAqIC0gQ2FwYWNpdG9yL0NvcmRvdmEgb24gaU9TOiBUaGUga2V5Ym9hcmQgb3ZlcmxheXMgdGhlIGNvbnRlbnRcclxuICogd2hlbiB0aGUgS2V5Ym9hcmRSZXNpemUgbW9kZSBpcyBzZXQgdG8gJ25vbmUnLlxyXG4gKi9cclxuY29uc3Qgc2V0U2Nyb2xsUGFkZGluZyA9IChjb250ZW50RWwsIHBhZGRpbmdBbW91bnQsIGNsZWFyQ2FsbGJhY2spID0+IHtcclxuICAgIGNvbnN0IHRpbWVyID0gY29udGVudEVsW1BBRERJTkdfVElNRVJfS0VZXTtcclxuICAgIGlmICh0aW1lcikge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICB9XHJcbiAgICBpZiAocGFkZGluZ0Ftb3VudCA+IDApIHtcclxuICAgICAgICBjb250ZW50RWwuc3R5bGUuc2V0UHJvcGVydHkoJy0ta2V5Ym9hcmQtb2Zmc2V0JywgYCR7cGFkZGluZ0Ftb3VudH1weGApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29udGVudEVsW1BBRERJTkdfVElNRVJfS0VZXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb250ZW50RWwuc3R5bGUuc2V0UHJvcGVydHkoJy0ta2V5Ym9hcmQtb2Zmc2V0JywgJzBweCcpO1xyXG4gICAgICAgICAgICBpZiAoY2xlYXJDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMTIwKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFdoZW4gYW4gaW5wdXQgaXMgYWJvdXQgdG8gYmUgZm9jdXNlZCxcclxuICogc2V0IGEgdGltZW91dCB0byBjbGVhciBhbnkgc2Nyb2xsIHBhZGRpbmdcclxuICogb24gdGhlIGNvbnRlbnQuIE5vdGU6IFRoZSBjbGVhcmluZ1xyXG4gKiBpcyBkb25lIG9uIGEgdGltZW91dCBzbyB0aGF0IGlmIHVzZXJzXHJcbiAqIGFyZSBtb3ZpbmcgZm9jdXMgZnJvbSBvbmUgaW5wdXQgdG8gdGhlIG5leHRcclxuICogdGhlbiByZS1hZGRpbmcgc2Nyb2xsIHBhZGRpbmcgdG8gdGhlIG5ld1xyXG4gKiBpbnB1dCB3aXRoIGNhbmNlbCB0aGUgdGltZW91dCB0byBjbGVhciB0aGVcclxuICogc2Nyb2xsIHBhZGRpbmcuXHJcbiAqL1xyXG5jb25zdCBzZXRDbGVhclNjcm9sbFBhZGRpbmdMaXN0ZW5lciA9IChpbnB1dEVsLCBjb250ZW50RWwsIGRvbmVDYWxsYmFjaykgPT4ge1xyXG4gICAgY29uc3QgY2xlYXJTY3JvbGxQYWRkaW5nID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChjb250ZW50RWwpIHtcclxuICAgICAgICAgICAgc2V0U2Nyb2xsUGFkZGluZyhjb250ZW50RWwsIDAsIGRvbmVDYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBjbGVhclNjcm9sbFBhZGRpbmcsIHsgb25jZTogdHJ1ZSB9KTtcclxufTtcclxuXHJcbmxldCBjdXJyZW50UGFkZGluZyA9IDA7XHJcbmNvbnN0IFNLSVBfU0NST0xMX0FTU0lTVCA9ICdkYXRhLWlvbmljLXNraXAtc2Nyb2xsLWFzc2lzdCc7XHJcbmNvbnN0IGVuYWJsZVNjcm9sbEFzc2lzdCA9IChjb21wb25lbnRFbCwgaW5wdXRFbCwgY29udGVudEVsLCBmb290ZXJFbCwga2V5Ym9hcmRIZWlnaHQsIGVuYWJsZVNjcm9sbFBhZGRpbmcsIGtleWJvYXJkUmVzaXplLCBkaXNhYmxlQ2xvbmVkSW5wdXQgPSBmYWxzZSkgPT4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTY3JvbGwgcGFkZGluZyBzaG91bGQgb25seSBiZSBhZGRlZCBpZjpcclxuICAgICAqIDEuIFRoZSBnbG9iYWwgc2Nyb2xsUGFkZGluZyBjb25maWcgb3B0aW9uXHJcbiAgICAgKiBpcyBzZXQgdG8gdHJ1ZS5cclxuICAgICAqIDIuIFRoZSBuYXRpdmUga2V5Ym9hcmQgcmVzaXplIG1vZGUgaXMgZWl0aGVyIFwibm9uZVwiXHJcbiAgICAgKiAoa2V5Ym9hcmQgb3ZlcmxheXMgd2Vidmlldykgb3IgdW5kZWZpbmVkIChyZXNpemVcclxuICAgICAqIGluZm9ybWF0aW9uIHVuYXZhaWxhYmxlKVxyXG4gICAgICogUmVzaXplIGluZm8gaXMgYXZhaWxhYmxlIG9uIENhcGFjaXRvciA0K1xyXG4gICAgICovXHJcbiAgICBjb25zdCBhZGRTY3JvbGxQYWRkaW5nID0gZW5hYmxlU2Nyb2xsUGFkZGluZyAmJiAoa2V5Ym9hcmRSZXNpemUgPT09IHVuZGVmaW5lZCB8fCBrZXlib2FyZFJlc2l6ZS5tb2RlID09PSBLZXlib2FyZFJlc2l6ZS5Ob25lKTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyB0cmFja3Mgd2hldGhlciBvciBub3QgdGhlIGtleWJvYXJkIGhhcyBiZWVuXHJcbiAgICAgKiBwcmVzZW50ZWQgZm9yIGEgc2luZ2xlIGZvY3VzZWQgdGV4dCBmaWVsZC4gTm90ZVxyXG4gICAgICogdGhhdCBpdCBkb2VzIG5vdCB0cmFjayBpZiB0aGUga2V5Ym9hcmQgaXMgb3BlblxyXG4gICAgICogaW4gZ2VuZXJhbCBzdWNoIGFzIGlmIHRoZSBrZXlib2FyZCBpcyBvcGVuIGZvclxyXG4gICAgICogYSBkaWZmZXJlbnQgZm9jdXNlZCB0ZXh0IGZpZWxkLlxyXG4gICAgICovXHJcbiAgICBsZXQgaGFzS2V5Ym9hcmRCZWVuUHJlc2VudGVkRm9yVGV4dEZpZWxkID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYWRkaW5nIHNjcm9sbCBwYWRkaW5nIHdlIG5lZWQgdG8ga25vd1xyXG4gICAgICogaG93IG11Y2ggb2YgdGhlIHZpZXdwb3J0IHRoZSBrZXlib2FyZCBvYnNjdXJlcy5cclxuICAgICAqIFdlIGRvIHRoaXMgYnkgc3VidHJhY3RpbmcgdGhlIGtleWJvYXJkIGhlaWdodFxyXG4gICAgICogZnJvbSB0aGUgcGxhdGZvcm0gaGVpZ2h0LlxyXG4gICAgICpcclxuICAgICAqIElmIHdlIGNvbXB1dGUgdGhpcyB2YWx1ZSB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuXHJcbiAgICAgKiBpbnB1dHMgdGhlbiB0aGUgd2VidmlldyBtYXkgYWxyZWFkeSBiZSByZXNpemVkLlxyXG4gICAgICogQXQgdGhpcyBwb2ludCwgYHdpbi5pbm5lckhlaWdodGAgaGFzIGFscmVhZHkgYWNjb3VudGVkXHJcbiAgICAgKiBmb3IgdGhlIGtleWJvYXJkIG1lYW5pbmcgd2Ugd291bGQgdGhlbiBzdWJ0cmFjdFxyXG4gICAgICogdGhlIGtleWJvYXJkIGhlaWdodCBhZ2Fpbi4gVGhpcyB3aWxsIHJlc3VsdCBpbiB0aGUgaW5wdXRcclxuICAgICAqIGJlaW5nIHNjcm9sbGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0by5cclxuICAgICAqL1xyXG4gICAgY29uc3QgcGxhdGZvcm1IZWlnaHQgPSB3aW4gIT09IHVuZGVmaW5lZCA/IHdpbi5pbm5lckhlaWdodCA6IDA7XHJcbiAgICAvKipcclxuICAgICAqIFNjcm9sbCBhc3Npc3QgaXMgcnVuIHdoZW4gYSB0ZXh0IGZpZWxkXHJcbiAgICAgKiBpcyBmb2N1c2VkLiBIb3dldmVyLCBpdCBtYXkgbmVlZCB0b1xyXG4gICAgICogcmUtcnVuIHdoZW4gdGhlIGtleWJvYXJkIHNpemUgY2hhbmdlc1xyXG4gICAgICogc3VjaCB0aGF0IHRoZSB0ZXh0IGZpZWxkIGlzIG5vdyBoaWRkZW5cclxuICAgICAqIHVuZGVybmVhdGggdGhlIGtleWJvYXJkLlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiByZS1ydW5zIHNjcm9sbCBhc3Npc3RcclxuICAgICAqIHdoZW4gdGhhdCBoYXBwZW5zLlxyXG4gICAgICpcclxuICAgICAqIE9uZSBsaW1pdGF0aW9uIG9mIHRoaXMgaXMgb24gYSB3ZWIgYnJvd3NlclxyXG4gICAgICogd2hlcmUgbmF0aXZlIGtleWJvYXJkIEFQSXMgZG8gbm90IGhhdmUgY3Jvc3MtYnJvd3NlclxyXG4gICAgICogc3VwcG9ydC4gYGlvbktleWJvYXJkRGlkU2hvd2AgcmVsaWVzIG9uIHRoZSBWaXN1YWwgVmlld3BvcnQgQVBJLlxyXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBrZXlib2FyZCBjaGFuZ2VzIGJ1dCBkb2VzIG5vdCBjaGFuZ2VcclxuICAgICAqIGdlb21ldHJ5LCB0aGVuIHNjcm9sbCBhc3Npc3Qgd2lsbCBub3QgcmUtcnVuIGV2ZW4gaWZcclxuICAgICAqIHRoZSB1c2VyIGhhcyBzY3JvbGxlZCB0aGUgdGV4dCBmaWVsZCB1bmRlciB0aGUga2V5Ym9hcmQuXHJcbiAgICAgKiBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2hlbiBydW5uaW5nIGluIENvcmRvdmEvQ2FwYWNpdG9yXHJcbiAgICAgKiBiZWNhdXNlIGBpb25LZXlib2FyZERpZFNob3dgIHVzZXMgdGhlIG5hdGl2ZSBldmVudHNcclxuICAgICAqIHdoaWNoIGZpcmUgZXZlcnkgdGltZSB0aGUga2V5Ym9hcmQgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgY29uc3Qga2V5Ym9hcmRTaG93ID0gKGV2KSA9PiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIGtleWJvYXJkIGhhcyBub3QgeWV0IGJlZW4gcHJlc2VudGVkXHJcbiAgICAgICAgICogZm9yIHRoaXMgdGV4dCBmaWVsZCB0aGVuIHRoZSB0ZXh0IGZpZWxkIGhhcyBqdXN0XHJcbiAgICAgICAgICogcmVjZWl2ZWQgZm9jdXMuIEluIHRoYXQgY2FzZSwgdGhlIGZvY3VzaW4gbGlzdGVuZXJcclxuICAgICAgICAgKiB3aWxsIHJ1biBzY3JvbGwgYXNzaXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChoYXNLZXlib2FyZEJlZW5QcmVzZW50ZWRGb3JUZXh0RmllbGQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGhhc0tleWJvYXJkQmVlblByZXNlbnRlZEZvclRleHRGaWVsZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3RoZXJ3aXNlLCB0aGUga2V5Ym9hcmQgaGFzIGFscmVhZHkgYmVlbiBwcmVzZW50ZWRcclxuICAgICAgICAgKiBmb3IgdGhlIGZvY3VzZWQgdGV4dCBmaWVsZC5cclxuICAgICAgICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIGtleWJvYXJkIGxpa2VseSBjaGFuZ2VkXHJcbiAgICAgICAgICogZ2VvbWV0cnksIGFuZCB3ZSBuZWVkIHRvIHJlLXJ1biBzY3JvbGwgYXNzaXN0LlxyXG4gICAgICAgICAqIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSB1c2VyIHJvdGF0ZXMgdGhlaXIgZGV2aWNlXHJcbiAgICAgICAgICogb3Igd2hlbiB0aGV5IHN3aXRjaCBrZXlib2FyZHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBNYWtlIHN1cmUgd2UgcGFzcyBpbiB0aGUgY29tcHV0ZWQga2V5Ym9hcmQgaGVpZ2h0XHJcbiAgICAgICAgICogcmF0aGVyIHRoYW4gdGhlIGVzdGltYXRlZCBrZXlib2FyZCBoZWlnaHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBTaW5jZSB0aGUga2V5Ym9hcmQgaXMgYWxyZWFkeSBvcGVuIHRoZW4gd2UgZG8gbm90XHJcbiAgICAgICAgICogbmVlZCB0byB3YWl0IGZvciB0aGUgd2VidmlldyB0byByZXNpemUsIHNvIHdlIHBhc3NcclxuICAgICAgICAgKiBcIndhaXRGb3JSZXNpemU6IGZhbHNlXCIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAganNTZXRGb2N1cyhjb21wb25lbnRFbCwgaW5wdXRFbCwgY29udGVudEVsLCBmb290ZXJFbCwgZXYuZGV0YWlsLmtleWJvYXJkSGVpZ2h0LCBhZGRTY3JvbGxQYWRkaW5nLCBkaXNhYmxlQ2xvbmVkSW5wdXQsIHBsYXRmb3JtSGVpZ2h0LCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgaW50ZXJuYWwgc3RhdGUgd2hlbiB0aGUgdGV4dCBmaWVsZCBsb3NlcyBmb2N1cy5cclxuICAgICAqL1xyXG4gICAgY29uc3QgZm9jdXNPdXQgPSAoKSA9PiB7XHJcbiAgICAgICAgaGFzS2V5Ym9hcmRCZWVuUHJlc2VudGVkRm9yVGV4dEZpZWxkID0gZmFsc2U7XHJcbiAgICAgICAgd2luID09PSBudWxsIHx8IHdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIGtleWJvYXJkU2hvdyk7XHJcbiAgICAgICAgY29tcG9uZW50RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBmb2N1c091dCwgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIHRoZSBpbnB1dCBpcyBhYm91dCB0byByZWNlaXZlXHJcbiAgICAgKiBmb2N1cywgd2UgbmVlZCB0byBtb3ZlIGl0IHRvIHByZXZlbnRcclxuICAgICAqIG1vYmlsZSBTYWZhcmkgZnJvbSBhZGp1c3RpbmcgdGhlIHZpZXdwb3J0LlxyXG4gICAgICovXHJcbiAgICBjb25zdCBmb2N1c0luID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNjcm9sbCBhc3Npc3Qgc2hvdWxkIG5vdCBydW4gYWdhaW5cclxuICAgICAgICAgKiBvbiBpbnB1dHMgdGhhdCBoYXZlIGJlZW4gbWFudWFsbHlcclxuICAgICAgICAgKiBmb2N1c2VkIGluc2lkZSBvZiB0aGUgc2Nyb2xsIGFzc2lzdFxyXG4gICAgICAgICAqIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChpbnB1dEVsLmhhc0F0dHJpYnV0ZShTS0lQX1NDUk9MTF9BU1NJU1QpKSB7XHJcbiAgICAgICAgICAgIGlucHV0RWwucmVtb3ZlQXR0cmlidXRlKFNLSVBfU0NST0xMX0FTU0lTVCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAganNTZXRGb2N1cyhjb21wb25lbnRFbCwgaW5wdXRFbCwgY29udGVudEVsLCBmb290ZXJFbCwga2V5Ym9hcmRIZWlnaHQsIGFkZFNjcm9sbFBhZGRpbmcsIGRpc2FibGVDbG9uZWRJbnB1dCwgcGxhdGZvcm1IZWlnaHQpO1xyXG4gICAgICAgIHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5hZGRFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBrZXlib2FyZFNob3cpO1xyXG4gICAgICAgIGNvbXBvbmVudEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm9jdXNPdXQsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIGNvbXBvbmVudEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmb2N1c0luLCB0cnVlKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgY29tcG9uZW50RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGZvY3VzSW4sIHRydWUpO1xyXG4gICAgICAgIHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBrZXlib2FyZFNob3cpO1xyXG4gICAgICAgIGNvbXBvbmVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm9jdXNPdXQsIHRydWUpO1xyXG4gICAgfTtcclxufTtcclxuLyoqXHJcbiAqIFVzZSB0aGlzIGZ1bmN0aW9uIHdoZW4geW91IHdhbnQgdG8gbWFudWFsbHlcclxuICogZm9jdXMgYW4gaW5wdXQgYnV0IG5vdCBoYXZlIHNjcm9sbCBhc3Npc3QgcnVuIGFnYWluLlxyXG4gKi9cclxuY29uc3Qgc2V0TWFudWFsRm9jdXMgPSAoZWwpID0+IHtcclxuICAgIC8qKlxyXG4gICAgICogSWYgZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQgdGhlblxyXG4gICAgICogYSBuZXcgZm9jdXNpbiBldmVudCB3aWxsIG5vdCBiZSBkaXNwYXRjaGVkXHJcbiAgICAgKiB0byByZW1vdmUgdGhlIFNLSUxfU0NST0xMX0FTU0lTVCBhdHRyaWJ1dGUuXHJcbiAgICAgKi9cclxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGVsLnNldEF0dHJpYnV0ZShTS0lQX1NDUk9MTF9BU1NJU1QsICd0cnVlJyk7XHJcbiAgICBlbC5mb2N1cygpO1xyXG59O1xyXG5jb25zdCBqc1NldEZvY3VzID0gYXN5bmMgKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBjb250ZW50RWwsIGZvb3RlckVsLCBrZXlib2FyZEhlaWdodCwgZW5hYmxlU2Nyb2xsUGFkZGluZywgZGlzYWJsZUNsb25lZElucHV0ID0gZmFsc2UsIHBsYXRmb3JtSGVpZ2h0ID0gMCwgd2FpdEZvclJlc2l6ZSA9IHRydWUpID0+IHtcclxuICAgIGlmICghY29udGVudEVsICYmICFmb290ZXJFbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHNjcm9sbERhdGEgPSBnZXRTY3JvbGxEYXRhKGNvbXBvbmVudEVsLCAoY29udGVudEVsIHx8IGZvb3RlckVsKSwga2V5Ym9hcmRIZWlnaHQsIHBsYXRmb3JtSGVpZ2h0KTtcclxuICAgIGlmIChjb250ZW50RWwgJiYgTWF0aC5hYnMoc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQpIDwgNCkge1xyXG4gICAgICAgIC8vIHRoZSB0ZXh0IGlucHV0IGlzIGluIGEgc2FmZSBwb3NpdGlvbiB0aGF0IGRvZXNuJ3RcclxuICAgICAgICAvLyByZXF1aXJlIGl0IHRvIGJlIHNjcm9sbGVkIGludG8gdmlldywganVzdCBzZXQgZm9jdXMgbm93XHJcbiAgICAgICAgc2V0TWFudWFsRm9jdXMoaW5wdXRFbCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXZlbiB0aG91Z2ggdGhlIGlucHV0IGRvZXMgbm90IG5lZWRcclxuICAgICAgICAgKiBzY3JvbGwgYXNzaXN0LCB3ZSBzaG91bGQgcHJlc2VydmUgdGhlXHJcbiAgICAgICAgICogdGhlIHNjcm9sbCBwYWRkaW5nIGFzIHVzZXJzIGNvdWxkIGJlIG1vdmluZ1xyXG4gICAgICAgICAqIGZvY3VzIGZyb20gYW4gaW5wdXQgdGhhdCBuZWVkcyBzY3JvbGwgcGFkZGluZ1xyXG4gICAgICAgICAqIHRvIGFuIGlucHV0IHRoYXQgZG9lcyBub3QgbmVlZCBzY3JvbGwgcGFkZGluZy5cclxuICAgICAgICAgKiBJZiB3ZSByZW1vdmUgdGhlIHNjcm9sbCBwYWRkaW5nIG5vdywgdXNlcnMgd2lsbFxyXG4gICAgICAgICAqIHNlZSB0aGUgcGFnZSBqdW1wLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChlbmFibGVTY3JvbGxQYWRkaW5nICYmIGNvbnRlbnRFbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRTY3JvbGxQYWRkaW5nKGNvbnRlbnRFbCwgY3VycmVudFBhZGRpbmcpO1xyXG4gICAgICAgICAgICBzZXRDbGVhclNjcm9sbFBhZGRpbmdMaXN0ZW5lcihpbnB1dEVsLCBjb250ZW50RWwsICgpID0+IChjdXJyZW50UGFkZGluZyA9IDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gdGVtcG9yYXJpbHkgbW92ZSB0aGUgZm9jdXMgdG8gdGhlIGZvY3VzIGhvbGRlciBzbyB0aGUgYnJvd3NlclxyXG4gICAgLy8gZG9lc24ndCBmcmVhayBvdXQgd2hpbGUgaXQncyB0cnlpbmcgdG8gZ2V0IHRoZSBpbnB1dCBpbiBwbGFjZVxyXG4gICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgbmF0aXZlIHRleHQgaW5wdXQgc3RpbGwgZG9lcyBub3QgaGF2ZSBmb2N1c1xyXG4gICAgcmVsb2NhdGVJbnB1dChjb21wb25lbnRFbCwgaW5wdXRFbCwgdHJ1ZSwgc2Nyb2xsRGF0YS5pbnB1dFNhZmVZLCBkaXNhYmxlQ2xvbmVkSW5wdXQpO1xyXG4gICAgc2V0TWFudWFsRm9jdXMoaW5wdXRFbCk7XHJcbiAgICAvKipcclxuICAgICAqIFJlbG9jYXRpbmcvRm9jdXNpbmcgaW5wdXQgY2F1c2VzIHRoZVxyXG4gICAgICogY2xpY2sgZXZlbnQgdG8gYmUgY2FuY2VsbGVkLCBzb1xyXG4gICAgICogbWFudWFsbHkgZmlyZSBvbmUgaGVyZS5cclxuICAgICAqL1xyXG4gICAgcmFmKCgpID0+IGNvbXBvbmVudEVsLmNsaWNrKCkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBlbmFibGVkLCB3ZSBjYW4gYWRkIHNjcm9sbCBwYWRkaW5nIHRvXHJcbiAgICAgKiB0aGUgYm90dG9tIG9mIHRoZSBjb250ZW50IHNvIHRoYXQgc2Nyb2xsIGFzc2lzdFxyXG4gICAgICogaGFzIGVub3VnaCByb29tIHRvIHNjcm9sbCB0aGUgaW5wdXQgYWJvdmVcclxuICAgICAqIHRoZSBrZXlib2FyZC5cclxuICAgICAqL1xyXG4gICAgaWYgKGVuYWJsZVNjcm9sbFBhZGRpbmcgJiYgY29udGVudEVsKSB7XHJcbiAgICAgICAgY3VycmVudFBhZGRpbmcgPSBzY3JvbGxEYXRhLnNjcm9sbFBhZGRpbmc7XHJcbiAgICAgICAgc2V0U2Nyb2xsUGFkZGluZyhjb250ZW50RWwsIGN1cnJlbnRQYWRkaW5nKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGxldCBzY3JvbGxDb250ZW50VGltZW91dDtcclxuICAgICAgICBjb25zdCBzY3JvbGxDb250ZW50ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjbGVhbiB1cCBsaXN0ZW5lcnMgYW5kIHRpbWVvdXRzXHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxDb250ZW50VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsQ29udGVudFRpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBkb3VibGVLZXlib2FyZEV2ZW50TGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93Jywgc2Nyb2xsQ29udGVudCk7XHJcbiAgICAgICAgICAgIC8vIHNjcm9sbCB0aGUgaW5wdXQgaW50byBwbGFjZVxyXG4gICAgICAgICAgICBpZiAoY29udGVudEVsKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBzY3JvbGxCeVBvaW50KGNvbnRlbnRFbCwgMCwgc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQsIHNjcm9sbERhdGEuc2Nyb2xsRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoZSBzY3JvbGwgdmlldyBpcyBpbiB0aGUgY29ycmVjdCBwb3NpdGlvbiBub3dcclxuICAgICAgICAgICAgLy8gZ2l2ZSB0aGUgbmF0aXZlIHRleHQgaW5wdXQgZm9jdXNcclxuICAgICAgICAgICAgcmVsb2NhdGVJbnB1dChjb21wb25lbnRFbCwgaW5wdXRFbCwgZmFsc2UsIHNjcm9sbERhdGEuaW5wdXRTYWZlWSk7XHJcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGlzIGlzIHRoZSBmb2N1c2VkIGlucHV0XHJcbiAgICAgICAgICAgIHNldE1hbnVhbEZvY3VzKGlucHV0RWwpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hlbiB0aGUgaW5wdXQgaXMgYWJvdXQgdG8gYmUgYmx1cnJlZFxyXG4gICAgICAgICAgICAgKiB3ZSBzaG91bGQgc2V0IGEgdGltZW91dCB0byByZW1vdmVcclxuICAgICAgICAgICAgICogYW55IHNjcm9sbCBwYWRkaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKGVuYWJsZVNjcm9sbFBhZGRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHNldENsZWFyU2Nyb2xsUGFkZGluZ0xpc3RlbmVyKGlucHV0RWwsIGNvbnRlbnRFbCwgKCkgPT4gKGN1cnJlbnRQYWRkaW5nID0gMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBkb3VibGVLZXlib2FyZEV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBkb3VibGVLZXlib2FyZEV2ZW50TGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93Jywgc2Nyb2xsQ29udGVudCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoY29udGVudEVsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEVsID0gYXdhaXQgZ2V0U2Nyb2xsRWxlbWVudChjb250ZW50RWwpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogc2Nyb2xsRGF0YSB3aWxsIG9ubHkgY29uc2lkZXIgdGhlIGFtb3VudCB3ZSBuZWVkXHJcbiAgICAgICAgICAgICAqIHRvIHNjcm9sbCBpbiBvcmRlciB0byBwcm9wZXJseSBicmluZyB0aGUgaW5wdXRcclxuICAgICAgICAgICAgICogaW50byB2aWV3LiBJdCB3aWxsIG5vdCBjb25zaWRlciB0aGUgYW1vdW50XHJcbiAgICAgICAgICAgICAqIHdlIGNhbiBzY3JvbGwgaW4gdGhlIGNvbnRlbnQgZWxlbWVudC5cclxuICAgICAgICAgICAgICogQXMgYSByZXN1bHQsIHNjcm9sbERhdGEgbWF5IHJlcXVlc3QgYSBncmVhdGVyXHJcbiAgICAgICAgICAgICAqIHNjcm9sbCBwb3NpdGlvbiB0aGFuIGlzIGN1cnJlbnRseSBhdmFpbGFibGVcclxuICAgICAgICAgICAgICogaW4gdGhlIERPTS4gSWYgdGhpcyBpcyB0aGUgY2FzZSwgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAgKiB3YWl0IGZvciB0aGUgd2VidmlldyB0byByZXNpemUvdGhlIGtleWJvYXJkXHJcbiAgICAgICAgICAgICAqIHRvIHNob3cgaW4gb3JkZXIgZm9yIGFkZGl0aW9uYWwgc2Nyb2xsXHJcbiAgICAgICAgICAgICAqIGJhbmR3aWR0aCB0byBiZWNvbWUgYXZhaWxhYmxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3QgdG90YWxTY3JvbGxBbW91bnQgPSBzY3JvbGxFbC5zY3JvbGxIZWlnaHQgLSBzY3JvbGxFbC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmICh3YWl0Rm9yUmVzaXplICYmIHNjcm9sbERhdGEuc2Nyb2xsQW1vdW50ID4gdG90YWxTY3JvbGxBbW91bnQgLSBzY3JvbGxFbC5zY3JvbGxUb3ApIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogT24gaU9TIGRldmljZXMsIHRoZSBzeXN0ZW0gd2lsbCBzaG93IGEgXCJQYXNzd29yZHNcIiBiYXIgYWJvdmUgdGhlIGtleWJvYXJkXHJcbiAgICAgICAgICAgICAgICAgKiBhZnRlciB0aGUgaW5pdGlhbCBrZXlib2FyZCBpcyBzaG93bi4gVGhpcyBwcmV2ZW50cyB0aGUgd2VidmlldyBmcm9tIHJlc2l6aW5nXHJcbiAgICAgICAgICAgICAgICAgKiB1bnRpbCB0aGUgXCJQYXNzd29yZHNcIiBiYXIgaXMgc2hvd24sIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhhdCB0byBoYXBwZW4gZmlyc3QuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dEVsLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgNTBweCB0byBhY2NvdW50IGZvciB0aGUgXCJQYXNzd29yZHNcIiBiYXJcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxEYXRhLnNjcm9sbEFtb3VudCArPSBTQ1JPTExfQU1PVU5UX1BBRERJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIGRvdWJsZUtleWJvYXJkRXZlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93Jywgc2Nyb2xsQ29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoaXMgc2hvdWxkIG9ubHkgZmlyZSBpbiAyIGluc3RhbmNlczpcclxuICAgICAgICAgICAgICAgICAqIDEuIFRoZSBhcHAgaXMgdmVyeSBzbG93LlxyXG4gICAgICAgICAgICAgICAgICogMi4gVGhlIGFwcCBpcyBydW5uaW5nIGluIGEgYnJvd3NlciBvbiBhbiBvbGQgT1NcclxuICAgICAgICAgICAgICAgICAqIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCBJb25pYyBLZXlib2FyZCBFdmVudHNcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsQ29udGVudFRpbWVvdXQgPSBzZXRUaW1lb3V0KHNjcm9sbENvbnRlbnQsIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjcm9sbENvbnRlbnQoKTtcclxuICAgIH1cclxufTtcclxuXHJcbmNvbnN0IElOUFVUX0JMVVJSSU5HID0gdHJ1ZTtcclxuY29uc3Qgc3RhcnRJbnB1dFNoaW1zID0gYXN5bmMgKGNvbmZpZywgcGxhdGZvcm0pID0+IHtcclxuICAgIC8qKlxyXG4gICAgICogSWYgZG9jIGlzIHVuZGVmaW5lZCB0aGVuIHdlIGFyZSBpbiBhbiBTU1IgZW52aXJvbm1lbnRcclxuICAgICAqIHdoZXJlIGlucHV0IHNoaW1zIGRvIG5vdCBhcHBseS5cclxuICAgICAqL1xyXG4gICAgaWYgKGRvYyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaXNJT1MgPSBwbGF0Zm9ybSA9PT0gJ2lvcyc7XHJcbiAgICBjb25zdCBpc0FuZHJvaWQgPSBwbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlIENhcmV0IGFuZCBJbnB1dCBCbHVycmluZyBhcmUgbmVlZGVkIG9uIGlPUy5cclxuICAgICAqIFNjcm9sbCBBc3Npc3QgYW5kIFNjcm9sbCBQYWRkaW5nIGFyZSBuZWVkZWQgb24gaU9TIGFuZCBBbmRyb2lkXHJcbiAgICAgKiB3aXRoIENocm9tZSB3ZWIgYnJvd3NlciAobm90IENocm9tZSB3ZWJ2aWV3KS5cclxuICAgICAqL1xyXG4gICAgY29uc3Qga2V5Ym9hcmRIZWlnaHQgPSBjb25maWcuZ2V0TnVtYmVyKCdrZXlib2FyZEhlaWdodCcsIDI5MCk7XHJcbiAgICBjb25zdCBzY3JvbGxBc3Npc3QgPSBjb25maWcuZ2V0Qm9vbGVhbignc2Nyb2xsQXNzaXN0JywgdHJ1ZSk7XHJcbiAgICBjb25zdCBoaWRlQ2FyZXQgPSBjb25maWcuZ2V0Qm9vbGVhbignaGlkZUNhcmV0T25TY3JvbGwnLCBpc0lPUyk7XHJcbiAgICBjb25zdCBpbnB1dEJsdXJyaW5nID0gY29uZmlnLmdldEJvb2xlYW4oJ2lucHV0Qmx1cnJpbmcnLCBpc0lPUyk7XHJcbiAgICBjb25zdCBzY3JvbGxQYWRkaW5nID0gY29uZmlnLmdldEJvb2xlYW4oJ3Njcm9sbFBhZGRpbmcnLCB0cnVlKTtcclxuICAgIGNvbnN0IGlucHV0cyA9IEFycmF5LmZyb20oZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lvbi1pbnB1dCwgaW9uLXRleHRhcmVhJykpO1xyXG4gICAgY29uc3QgaGlkZUNhcmV0TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIGNvbnN0IHNjcm9sbEFzc2lzdE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAvKipcclxuICAgICAqIEdyYWIgdGhlIG5hdGl2ZSBrZXlib2FyZCByZXNpemUgY29uZmlndXJhdGlvblxyXG4gICAgICogYW5kIHBhc3MgaXQgdG8gc2Nyb2xsIGFzc2lzdC4gU2Nyb2xsIGFzc2lzdCByZXF1aXJlc1xyXG4gICAgICogdGhhdCB3ZSBhZGp1c3QgdGhlIGlucHV0IHJpZ2h0IGJlZm9yZSB0aGUgaW5wdXRcclxuICAgICAqIGlzIGFib3V0IHRvIGJlIGZvY3VzZWQuIElmIHdlIGNhbGxlZCBgS2V5Ym9hcmQuZ2V0UmVzaXplTW9kZWBcclxuICAgICAqIG9uIGZvY3VzaW4gaW4gc2Nyb2xsIGFzc2lzdCwgd2UgY291bGQgcG90ZW50aWFsbHkgYWRqdXN0IHRoZVxyXG4gICAgICogaW5wdXQgdG9vIGxhdGUgc2luY2UgdGhpcyBjYWxsIGlzIGFzeW5jLlxyXG4gICAgICovXHJcbiAgICBjb25zdCBrZXlib2FyZFJlc2l6ZU1vZGUgPSBhd2FpdCBLZXlib2FyZC5nZXRSZXNpemVNb2RlKCk7XHJcbiAgICBjb25zdCByZWdpc3RlcklucHV0ID0gYXN5bmMgKGNvbXBvbmVudEVsKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IGNvbXBvbmVudE9uUmVhZHkoY29tcG9uZW50RWwsIHJlc29sdmUpKTtcclxuICAgICAgICBjb25zdCBpbnB1dFJvb3QgPSBjb21wb25lbnRFbC5zaGFkb3dSb290IHx8IGNvbXBvbmVudEVsO1xyXG4gICAgICAgIGNvbnN0IGlucHV0RWwgPSBpbnB1dFJvb3QucXVlcnlTZWxlY3RvcignaW5wdXQnKSB8fCBpbnB1dFJvb3QucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKTtcclxuICAgICAgICBjb25zdCBzY3JvbGxFbCA9IGZpbmRDbG9zZXN0SW9uQ29udGVudChjb21wb25lbnRFbCk7XHJcbiAgICAgICAgY29uc3QgZm9vdGVyRWwgPSAhc2Nyb2xsRWwgPyBjb21wb25lbnRFbC5jbG9zZXN0KCdpb24tZm9vdGVyJykgOiBudWxsO1xyXG4gICAgICAgIGlmICghaW5wdXRFbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghIXNjcm9sbEVsICYmIGhpZGVDYXJldCAmJiAhaGlkZUNhcmV0TWFwLmhhcyhjb21wb25lbnRFbCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgcm1GbiA9IGVuYWJsZUhpZGVDYXJldE9uU2Nyb2xsKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzY3JvbGxFbCk7XHJcbiAgICAgICAgICAgIGhpZGVDYXJldE1hcC5zZXQoY29tcG9uZW50RWwsIHJtRm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBkYXRlL2RhdGV0aW1lLWxvY2FsZSBpbnB1dHMgb24gbW9iaWxlIGRldmljZXMgc2hvdyBkYXRlIHBpY2tlclxyXG4gICAgICAgICAqIG92ZXJsYXlzIGluc3RlYWQgb2Yga2V5Ym9hcmRzLiBBcyBhIHJlc3VsdCwgc2Nyb2xsIGFzc2lzdCBpc1xyXG4gICAgICAgICAqIG5vdCBuZWVkZWQuIFRoaXMgYWxzbyB3b3JrcyBhcm91bmQgYSBidWcgaW4gaU9TIDwxNiB3aGVyZVxyXG4gICAgICAgICAqIHNjcm9sbCBhc3Npc3QgY2F1c2VzIHRoZSBicm93c2VyIHRvIGxvY2sgdXAuIFNlZSBGVy0xOTk3LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IGlzRGF0ZUlucHV0ID0gaW5wdXRFbC50eXBlID09PSAnZGF0ZScgfHwgaW5wdXRFbC50eXBlID09PSAnZGF0ZXRpbWUtbG9jYWwnO1xyXG4gICAgICAgIGlmICghaXNEYXRlSW5wdXQgJiZcclxuICAgICAgICAgICAgKCEhc2Nyb2xsRWwgfHwgISFmb290ZXJFbCkgJiZcclxuICAgICAgICAgICAgc2Nyb2xsQXNzaXN0ICYmXHJcbiAgICAgICAgICAgICFzY3JvbGxBc3Npc3RNYXAuaGFzKGNvbXBvbmVudEVsKSkge1xyXG4gICAgICAgICAgICBjb25zdCBybUZuID0gZW5hYmxlU2Nyb2xsQXNzaXN0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzY3JvbGxFbCwgZm9vdGVyRWwsIGtleWJvYXJkSGVpZ2h0LCBzY3JvbGxQYWRkaW5nLCBrZXlib2FyZFJlc2l6ZU1vZGUsIGlzQW5kcm9pZCk7XHJcbiAgICAgICAgICAgIHNjcm9sbEFzc2lzdE1hcC5zZXQoY29tcG9uZW50RWwsIHJtRm4pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1bnJlZ2lzdGVySW5wdXQgPSAoY29tcG9uZW50RWwpID0+IHtcclxuICAgICAgICBpZiAoaGlkZUNhcmV0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZuID0gaGlkZUNhcmV0TWFwLmdldChjb21wb25lbnRFbCk7XHJcbiAgICAgICAgICAgIGlmIChmbikge1xyXG4gICAgICAgICAgICAgICAgZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoaWRlQ2FyZXRNYXAuZGVsZXRlKGNvbXBvbmVudEVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNjcm9sbEFzc2lzdCkge1xyXG4gICAgICAgICAgICBjb25zdCBmbiA9IHNjcm9sbEFzc2lzdE1hcC5nZXQoY29tcG9uZW50RWwpO1xyXG4gICAgICAgICAgICBpZiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2Nyb2xsQXNzaXN0TWFwLmRlbGV0ZShjb21wb25lbnRFbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmIChpbnB1dEJsdXJyaW5nICYmIElOUFVUX0JMVVJSSU5HKSB7XHJcbiAgICAgICAgZW5hYmxlSW5wdXRCbHVycmluZygpO1xyXG4gICAgfVxyXG4gICAgLy8gSW5wdXQgbWlnaHQgYmUgYWxyZWFkeSBsb2FkZWQgaW4gdGhlIERPTSBiZWZvcmUgaW9uLWRldmljZS1oYWNrcyBkaWQuXHJcbiAgICAvLyBBdCB0aGlzIHBvaW50IHdlIG5lZWQgdG8gbG9vayBmb3IgYWxsIG9mIHRoZSBpbnB1dHMgbm90IHJlZ2lzdGVyZWQgeWV0XHJcbiAgICAvLyBhbmQgcmVnaXN0ZXIgdGhlbS5cclxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XHJcbiAgICAgICAgcmVnaXN0ZXJJbnB1dChpbnB1dCk7XHJcbiAgICB9XHJcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignaW9uSW5wdXREaWRMb2FkJywgKGV2KSA9PiB7XHJcbiAgICAgICAgcmVnaXN0ZXJJbnB1dChldi5kZXRhaWwpO1xyXG4gICAgfSk7XHJcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignaW9uSW5wdXREaWRVbmxvYWQnLCAoZXYpID0+IHtcclxuICAgICAgICB1bnJlZ2lzdGVySW5wdXQoZXYuZGV0YWlsKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0IHsgc3RhcnRJbnB1dFNoaW1zIH07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==